

### FILE: C:\Users\Legion\AI_VET_Assistant-2\check_api.py ###

import os
from dotenv import load_dotenv
import requests

load_dotenv()

api_key = os.getenv('OPENROUTER_API_KEY')
print(f"API Key: {api_key[:15]}...")

response = requests.get(
    'https://openrouter.ai/api/v1/auth/key',
    headers={'Authorization': f'Bearer {api_key}'}
)
print("Status:", response.status_code)
print("Response:", response.json())


### FILE: C:\Users\Legion\AI_VET_Assistant-2\config.py ###

import os
from dotenv import load_dotenv

load_dotenv()

# API
BOT_API_KEY = os.getenv('BOT_API_KEY')
OPENROUTER_API_KEY = os.getenv('OPENROUTER_API_KEY')
DEEPINFRA_API_KEY = os.getenv('DEEPINFRA_API_KEY')

# Gmail SMTP config
EMAIL_HOST = os.getenv('EMAIL_HOST', 'smtp.gmail.com')
EMAIL_PORT = int(os.getenv('EMAIL_PORT', 587))
EMAIL_LOGIN = os.getenv('EMAIL_LOGIN')
EMAIL_PASSWORD = os.getenv('EMAIL_PASSWORD')
EMAIL_TO = os.getenv('EMAIL_TO')



### FILE: C:\Users\Legion\AI_VET_Assistant-2\main.py ###

import asyncio
from bot.handlers import bot, dp
from src.database.db_init import db

async def main():
    await db.create_tables()
    print("[INFO] Starting bot polling…")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print('Shut down')


### FILE: C:\Users\Legion\AI_VET_Assistant-2\models.py ###

import aiosqlite
from datetime import datetime

class Database:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    async def create_tables(self):
        async with aiosqlite.connect(self.db_path) as db:
            # Таблица пользователей
            await db.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id INTEGER PRIMARY KEY,
                    username TEXT,
                    client_code TEXT UNIQUE,
                    pet_name TEXT,
                    pet_type TEXT,
                    country TEXT DEFAULT 'RU',
                    registration_date TIMESTAMP,
                    role TEXT DEFAULT 'client',
                    is_active BOOLEAN DEFAULT TRUE
                )
            ''')
            
            # Таблица для жалоб и предложений
            await db.execute('''
                CREATE TABLE IF NOT EXISTS feedback (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    feedback_type TEXT,
                    message TEXT,
                    timestamp TIMESTAMP,
                    status TEXT DEFAULT 'new',
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            # Упрощенная таблица для кодов активации (без срока действия)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS activation_codes (
                    code TEXT PRIMARY KEY,
                    role TEXT,
                    is_used BOOLEAN DEFAULT FALSE,
                    used_by INTEGER,
                    used_at TIMESTAMP,
                    created_at TIMESTAMP
                )
            ''')
            
            # Таблица для статистики запросов
            await db.execute('''
                CREATE TABLE IF NOT EXISTS request_statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    request_type TEXT,
                    request_text TEXT,
                    timestamp TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            await db.commit()
            await self._migrate_database(db)
    
    async def _migrate_database(self, db):
        """Проверка и обновление структуры БД"""
        cursor = await db.execute("PRAGMA table_info(users)")
        columns = await cursor.fetchall()
        column_names = [col[1] for col in columns]
        
        # Миграция старых ролей на новые
        if 'role' in column_names:
            await db.execute("UPDATE users SET role = 'client' WHERE role = 'user'")
            await db.execute("UPDATE users SET role = 'staff' WHERE role IN ('moderator', 'vip')")
        
        if 'country' not in column_names:
            await db.execute("ALTER TABLE users ADD COLUMN country TEXT DEFAULT 'RU'")
            
        await db.commit()
    
    async def add_user(self, telegram_id: int, username: str, 
                      client_code: str, pet_name: str, pet_type: str, country: str = 'RU'):
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO users (telegram_id, username, client_code, 
                                     pet_name, pet_type, country, registration_date, role)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (telegram_id, username, client_code, pet_name, 
                     pet_type, country, datetime.now(), 'client'))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
            except Exception as e:
                print(f"Error adding user: {e}")
                return False
    
    async def get_user(self, telegram_id: int):
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                'SELECT * FROM users WHERE telegram_id = ?', 
                (telegram_id,)
            )
            return await cursor.fetchone()
    
    async def get_user_role(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user['role'] if user else None
    
    async def update_user_role(self, telegram_id: int, role: str):
        """Обновление роли пользователя (навсегда)"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute(
                'UPDATE users SET role = ? WHERE telegram_id = ?',
                (role, telegram_id)
            )
            await db.commit()
    
    async def check_activation_code(self, code: str):
        """Проверка кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute('''
                SELECT * FROM activation_codes 
                WHERE code = ? AND is_used = FALSE
            ''', (code.upper(),))
            return await cursor.fetchone()
    
    async def use_activation_code(self, code: str, user_id: int):
        """Использование кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                UPDATE activation_codes 
                SET is_used = TRUE, used_by = ?, used_at = ?
                WHERE code = ?
            ''', (user_id, datetime.now(), code.upper()))
            await db.commit()
    
    async def create_activation_code(self, code: str, role: str):
        """Создание одноразового кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO activation_codes (code, role, created_at)
                    VALUES (?, ?, ?)
                ''', (code.upper(), role, datetime.now()))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def user_exists(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user is not None
    
    async def check_client_code_exists(self, client_code: str):
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute(
                'SELECT telegram_id FROM users WHERE client_code = ?', 
                (client_code,)
            )
            result = await cursor.fetchone()
            return result is not None
    
    async def add_request_stat(self, user_id: int, request_type: str, 
                              request_text: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO request_statistics (user_id, request_type, 
                                              request_text, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, request_type, request_text, datetime.now()))
            await db.commit()
    
    async def add_feedback(self, user_id: int, feedback_type: str, message: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO feedback (user_id, feedback_type, message, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, feedback_type, message, datetime.now()))
            await db.commit()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\parser.py ###

from telegram import Update
from telegram.ext import Application, MessageHandler, filters

async def get_file_id(update: Update, context):
    if update.message.photo:
        file_id = update.message.photo[-1].file_id
        await update.message.reply_text(f"Photo file_id: {file_id}")
    elif update.message.document:
        file_id = update.message.document.file_id
        await update.message.reply_text(f"Document file_id: {file_id}")

app = Application.builder().token("8136766001:AAGKhc5s3yWEvYsNP9MFuC2LSZntFQSlDQg").build()
app.add_handler(MessageHandler(filters.ALL, get_file_id))
app.run_polling()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\keyboards.py ###

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_cancel_kb():
    kb = [
        [KeyboardButton(text="🔙 Вернуться в главное меню")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_country_kb():
    """Клавиатура выбора страны"""
    kb = [
        [KeyboardButton(text="🇧🇾 Беларусь"), KeyboardButton(text="🇷🇺 Россия")],       
        [KeyboardButton(text="🇰🇿 Казахстан"), KeyboardButton(text="🇦🇲 Армения")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_user_type_kb():
    """Клавиатура выбора типа пользователя"""
    kb = [
        [KeyboardButton(text="👨‍⚕️ Ветеринарный врач клиники-партнера")],
        [KeyboardButton(text="🔬 Сотрудник VET UNION")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_specialization_kb():
    """Клавиатура выбора специализации для ветеринарных врачей"""
    kb = [
        [KeyboardButton(text="🏥 Общая практика"), KeyboardButton(text="🔪 Хирургия"), KeyboardButton(text="💊 Терапия")],
        [KeyboardButton(text="🦴 Ортопедия"), KeyboardButton(text="🎗️ Онкология"), KeyboardButton(text="👨‍⚕️ Дерматология")], 
        [KeyboardButton(text="🦷 Стоматология"), KeyboardButton(text="👁️ Офтальмология")],
        [KeyboardButton(text="✏️ Ввести свою специализацию")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_region_kb_belarus():
    """Клавиатура выбора региона для Беларуси"""
    kb = [
        [KeyboardButton(text="📍 Минск"), KeyboardButton(text="📍 Минская область")],
        [KeyboardButton(text="📍 Брест"), KeyboardButton(text="📍 Брестская область")],
        [KeyboardButton(text="📍 Гомель"), KeyboardButton(text="📍 Гомельская область")],
        [KeyboardButton(text="📍 Гродно"), KeyboardButton(text="📍 Гродненская область")],
        [KeyboardButton(text="📍 Могилев"), KeyboardButton(text="📍 Могилевская область")],
        [KeyboardButton(text="📍 Витебск"), KeyboardButton(text="📍 Витебская область")],
        [KeyboardButton(text="✏️ Ввести свой регион")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_region_kb_russia():
    """Клавиатура выбора региона для России"""
    kb = [
        [KeyboardButton(text="📍 Москва"), KeyboardButton(text="📍 Московская область")],
        [KeyboardButton(text="📍 Санкт-Петербург"), KeyboardButton(text="📍 Ленинградская область")],
        [KeyboardButton(text="📍 Новосибирск"), KeyboardButton(text="📍 Екатеринбург")],
        [KeyboardButton(text="📍 Нижний Новгород"), KeyboardButton(text="📍 Казань")],
        [KeyboardButton(text="📍 Челябинск"), KeyboardButton(text="📍 Омск")],
        [KeyboardButton(text="📍 Самара"), KeyboardButton(text="📍 Ростов-на-Дону")],
        [KeyboardButton(text="📍 Уфа"), KeyboardButton(text="📍 Красноярск")],
        [KeyboardButton(text="✏️ Ввести свой регион")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_region_kb_kazakhstan():
    """Клавиатура выбора региона для Казахстана"""
    kb = [
        [KeyboardButton(text="📍 Алматы"), KeyboardButton(text="📍 Астана (Нур-Султан)")],
        [KeyboardButton(text="📍 Шымкент"), KeyboardButton(text="📍 Караганда")],
        [KeyboardButton(text="📍 Актобе"), KeyboardButton(text="📍 Павлодар")],
        [KeyboardButton(text="📍 Тараз"), KeyboardButton(text="📍 Усть-Каменогорск")],
        [KeyboardButton(text="📍 Семей"), KeyboardButton(text="📍 Атырау")],
        [KeyboardButton(text="📍 Костанай"), KeyboardButton(text="📍 Кызылорда")],
        [KeyboardButton(text="✏️ Ввести свой регион")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_region_kb_armenia():
    """Клавиатура выбора региона для Армении"""
    kb = [
        [KeyboardButton(text="📍 Ереван"), KeyboardButton(text="📍 Гюмри")],
        [KeyboardButton(text="📍 Ванадзор"), KeyboardButton(text="📍 Вагаршапат")],
        [KeyboardButton(text="📍 Абовян"), KeyboardButton(text="📍 Капан")],
        [KeyboardButton(text="📍 Раздан"), KeyboardButton(text="📍 Армавир")],
        [KeyboardButton(text="📍 Арташат"), KeyboardButton(text="📍 Севан")],
        [KeyboardButton(text="📍 Горис"), KeyboardButton(text="📍 Аштарак")],
        [KeyboardButton(text="✏️ Ввести свой регион")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_region_kb(country: str = 'BY'):
    """Получить клавиатуру региона по коду страны"""
    if country == 'BY':
        return get_region_kb_belarus()
    elif country == 'RU':
        return get_region_kb_russia()
    elif country == 'KZ':
        return get_region_kb_kazakhstan()
    elif country == 'AM':
        return get_region_kb_armenia()
    else:
        return get_region_kb_belarus()  # По умолчанию

def get_department_function_kb():
    """Клавиатура выбора функции сотрудника"""
    kb = [
        [KeyboardButton(text="🔬 Лаборатория")],
        [KeyboardButton(text="💰 Продажи")],
        [KeyboardButton(text="🤝 Поддержка")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_main_menu_kb():
    """Единое меню для всех пользователей (кроме админа)"""
    kb = [
        [KeyboardButton(text="🤖 Задать вопрос ассистенту")],
        [KeyboardButton(text="📞 Заказать звонок")],
        [KeyboardButton(text="💡 Предложения и пожелания")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_admin_menu_kb():
    """Меню для администраторов"""
    kb = [
        [KeyboardButton(text="📊 Статистика"), KeyboardButton(text="👥 Пользователи")],
        [KeyboardButton(text="📋 Все обращения"), KeyboardButton(text="🔐 Создать код")],
        [KeyboardButton(text="📥 Выгрузка в Excel"), KeyboardButton(text="📢 Рассылка")],
        [KeyboardButton(text="🤖 Задать вопрос ассистенту"), KeyboardButton(text="📞 Заказать звонок")],
        [KeyboardButton(text="💡 Предложения и пожелания")],
        [KeyboardButton(text="🔧 Управление системой")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_phone_kb():
    kb = [
        [KeyboardButton(text="📱 Поделиться номером", request_contact=True)]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_feedback_type_kb():
    kb = [
        [KeyboardButton(text="💡 Предложение"), KeyboardButton(text="⚠️ Жалоба")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_menu_by_role(role: str):
    """Получить меню в зависимости от роли"""
    if role == 'admin':
        return get_admin_menu_kb()
    else:
        return get_main_menu_kb()
    
def get_dialog_kb():
    """Клавиатура для режима диалога с ботом."""
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="🔄 Новый вопрос")],
            [KeyboardButton(text="❌ Завершить диалог")]
        ],
        resize_keyboard=True,
        one_time_keyboard=False
    )

def get_excel_export_kb():
    """Клавиатура для выбора типа выгрузки"""
    kb = [
        [KeyboardButton(text="📊 Полная выгрузка")],
        [KeyboardButton(text="👥 Только пользователи")],
        [KeyboardButton(text="❓ Только вопросы")],
        [KeyboardButton(text="📞 Только звонки")],
        [KeyboardButton(text="💡 Только обратная связь")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_broadcast_type_kb():
    """Клавиатура для выбора типа рассылки"""
    kb = [
        [KeyboardButton(text="📢 Всем пользователям")],
        [KeyboardButton(text="👨‍⚕️ Только клиентам")],
        [KeyboardButton(text="🔬 Только сотрудникам")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_system_management_kb():
    """Клавиатура управления системой"""
    kb = [
        [KeyboardButton(text="🔄 Обновить векторную БД")],
        [KeyboardButton(text="🗑️ Очистить старые логи")],
        [KeyboardButton(text="📊 Системная информация")],
        [KeyboardButton(text="🔙 Назад")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

# Для совместимости
get_client_menu_kb = get_main_menu_kb
get_staff_menu_kb = get_main_menu_kb


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\__init__.py ###



### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\activation.py ###

from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_admin_menu_kb, get_main_menu_kb

from src.database.db_init import db

activation_router = Router()

class ActivationStates(StatesGroup):
    waiting_for_code = State()

@activation_router.message(F.text == "🔑 Активировать код")
async def start_activation(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Необходимо пройти регистрацию. Используйте /start")
        return
    
    if user['role'] == 'admin':
        await message.answer(
            "Вы уже являетесь администратором!",
            reply_markup=get_admin_menu_kb()
        )
        return
    
    await message.answer(
        "Введите код активации администратора:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(ActivationStates.waiting_for_code)

@activation_router.message(ActivationStates.waiting_for_code)
async def process_activation_code(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "🔙 Вернуться в главное меню":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_main_menu_kb())
        return
    
    code = message.text.strip().upper()
    activation = await db.check_activation_code(code)
    
    if activation:
        await db.use_activation_code(code, user_id)
        await db.update_user_role(user_id, 'admin')
        
        await message.answer(
            "✅ Код успешно активирован!\n"
            "Теперь вы администратор системы.",
            reply_markup=get_admin_menu_kb()
        )
    else:
        await message.answer(
            "❌ Неверный или уже использованный код.\n"
            "Попробуйте еще раз или нажмите Отмена.",
            reply_markup=get_cancel_kb()
        )
        return
    
    await state.clear()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\admin.py ###

import random
import string
from aiogram import Router, F
from aiogram.types import Message, BufferedInputFile
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import (
    get_cancel_kb, get_admin_menu_kb, get_main_menu_kb, 
    get_excel_export_kb, get_broadcast_type_kb, get_system_management_kb
)
from utils.excel_exporter import ExcelExporter
from datetime import datetime
import asyncio

from src.database.db_init import db

admin_router = Router()

class ActivationStates(StatesGroup):
    waiting_for_code = State()

class ExportStates(StatesGroup):
    choosing_export_type = State()

class BroadcastStates(StatesGroup):
    choosing_broadcast_type = State()
    waiting_for_message = State()

class SystemStates(StatesGroup):
    in_system_menu = State()

@admin_router.message(F.text == "🔑 Активировать код")
async def start_activation(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Необходимо пройти регистрацию. Используйте /start")
        return
    
    if user['role'] == 'admin':
        await message.answer(
            "Вы уже являетесь администратором!",
            reply_markup=get_admin_menu_kb()
        )
        return
    
    await message.answer(
        "Введите код активации администратора:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(ActivationStates.waiting_for_code)

@admin_router.message(ActivationStates.waiting_for_code)
async def process_activation_code(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "🔙 Вернуться в главное меню":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_main_menu_kb())
        return
    
    code = message.text.strip().upper()
    activation = await db.check_activation_code(code)
    
    if activation:
        await db.use_activation_code(code, user_id)
        await db.update_user_role(user_id, 'admin')
        
        await message.answer(
            "✅ Код успешно активирован!\n"
            "Теперь вы администратор системы.",
            reply_markup=get_admin_menu_kb()
        )
    else:
        await message.answer(
            "❌ Неверный или уже использованный код.\n"
            "Попробуйте еще раз или нажмите Отмена.",
            reply_markup=get_cancel_kb()
        )
        return
    
    await state.clear()

@admin_router.message(F.text == "🔐 Создать код")
async def create_code(message: Message):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
    admin_code = f"ADMIN{code}"
    
    await db.create_admin_code(admin_code)
    
    await message.answer(
        "✅ Код активации создан:\n\n"
        f"👨‍💼 Для администратора: `{admin_code}`\n\n"
        "Код одноразовый и действует бессрочно.",
        parse_mode="Markdown",
        reply_markup=get_admin_menu_kb()
    )

@admin_router.message(F.text == "📊 Статистика")
async def show_stats(message: Message):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    stats = await db.get_statistics()
    
    await message.answer(
        f"📊 Статистика системы:\n\n"
        f"👥 Всего пользователей: {stats['total_users']}\n"
        f"├ Клиентов: {stats['clients']}\n"
        f"├ Сотрудников: {stats['employees']}\n"
        f"└ Администраторов: {stats['admins']}\n\n"
        f"📋 Обращений: {stats['total_requests']}\n"
        f"❓ Вопросов: {stats['questions']}\n"
        f"📞 Звонков: {stats['callbacks']}\n"
        f"💡 Предложений: {stats['suggestions']}\n"
        f"⚠️ Жалоб: {stats['complaints']}",
        reply_markup=get_admin_menu_kb()
    )

@admin_router.message(F.text == "📥 Выгрузка в Excel")
async def start_excel_export(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    await message.answer(
        "Выберите тип выгрузки:",
        reply_markup=get_excel_export_kb()
    )
    await state.set_state(ExportStates.choosing_export_type)

@admin_router.message(ExportStates.choosing_export_type)
async def process_export_choice(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "🔙 Вернуться в главное меню":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_admin_menu_kb())
        return
    
    loading_msg = await message.answer("⏳ Подготавливаю файл для выгрузки...")
    
    try:
        exporter = ExcelExporter(db.db_path)
        filename = f"export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        
        if message.text == "📊 Полная выгрузка":
            excel_data = await exporter.export_all_data()
            filename = f"full_{filename}"
            caption = "📊 Полная выгрузка данных системы"
        
        elif message.text == "👥 Только пользователи":
            excel_data = await exporter.export_users()
            filename = f"users_{filename}"
            caption = "👥 Выгрузка пользователей"
        
        elif message.text == "❓ Только вопросы":
            excel_data = await exporter.export_questions()
            filename = f"questions_{filename}"
            caption = "❓ Выгрузка вопросов"
        
        elif message.text == "📞 Только звонки":
            excel_data = await exporter.export_callbacks()
            filename = f"callbacks_{filename}"
            caption = "📞 Выгрузка запросов на звонок"
        
        elif message.text == "💡 Только обратная связь":
            excel_data = await exporter.export_feedback()
            filename = f"feedback_{filename}"
            caption = "💡 Выгрузка обратной связи"
        
        else:
            await loading_msg.delete()
            await message.answer(
                "Неизвестный тип выгрузки. Выберите из предложенных вариантов.",
                reply_markup=get_excel_export_kb()
            )
            return
        
        await loading_msg.delete()
        
        await message.answer_document(
            BufferedInputFile(excel_data, filename),
            caption=f"{caption}\n📅 Дата выгрузки: {datetime.now().strftime('%d.%m.%Y %H:%M')}",
            reply_markup=get_admin_menu_kb()
        )
        
        await state.clear()
        
    except Exception as e:
        await loading_msg.delete()
        await message.answer(
            f"❌ Ошибка при создании выгрузки: {str(e)}",
            reply_markup=get_admin_menu_kb()
        )
        await state.clear()

@admin_router.message(F.text == "📢 Рассылка")
async def start_broadcast(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    await message.answer(
        "Выберите получателей рассылки:",
        reply_markup=get_broadcast_type_kb()
    )
    await state.set_state(BroadcastStates.choosing_broadcast_type)

@admin_router.message(BroadcastStates.choosing_broadcast_type)
async def process_broadcast_type(message: Message, state: FSMContext):
    if message.text == "🔙 Вернуться в главное меню":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_admin_menu_kb())
        return
    
    broadcast_types = {
        "📢 Всем пользователям": "all",
        "👨‍⚕️ Только клиентам": "clients",
        "🔬 Только сотрудникам": "employees"
    }
    
    if message.text not in broadcast_types:
        await message.answer(
            "Выберите тип рассылки из предложенных вариантов.",
            reply_markup=get_broadcast_type_kb()
        )
        return
    
    await state.update_data(broadcast_type=broadcast_types[message.text])
    await message.answer(
        "📝 Введите текст сообщения для рассылки:\n\n"
        "Поддерживается HTML-форматирование:\n"
        "• <b>жирный</b>\n"
        "• <i>курсив</i>\n"
        "• <code>код</code>",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(BroadcastStates.waiting_for_message)

@admin_router.message(BroadcastStates.waiting_for_message)
async def process_broadcast_message(message: Message, state: FSMContext):
    if message.text == "🔙 Вернуться в главное меню":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_admin_menu_kb())
        return
    
    data = await state.get_data()
    broadcast_type = data['broadcast_type']
    
    recipients = await db.get_broadcast_recipients(broadcast_type)
    
    if not recipients:
        await message.answer(
            "❌ Не найдено получателей для рассылки.",
            reply_markup=get_admin_menu_kb()
        )
        await state.clear()
        return
    
    await message.answer(
        f"📢 Рассылка будет отправлена {len(recipients)} получателям.\n\n"
        f"Текст сообщения:\n{message.text}\n\n"
        "Начинаю рассылку..."
    )
    
    from bot.handlers import bot
    success_count = 0
    failed_count = 0
    
    for recipient_id in recipients:
        try:
            await bot.send_message(
                recipient_id,
                f"📢 <b>Сообщение от администрации VET UNION</b>\n\n{message.text}",
                parse_mode="HTML"
            )
            success_count += 1
            await asyncio.sleep(0.1)
        except Exception as e:
            failed_count += 1
            print(f"Failed to send to {recipient_id}: {e}")
    
    await message.answer(
        f"✅ Рассылка завершена!\n\n"
        f"📤 Успешно отправлено: {success_count}\n"
        f"❌ Не удалось отправить: {failed_count}",
        reply_markup=get_admin_menu_kb()
    )
    await state.clear()

@admin_router.message(F.text == "👥 Пользователи")
async def show_users(message: Message):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    users_info = await db.get_recent_users(limit=10)
    
    if not users_info:
        await message.answer(
            "Пользователей пока нет.",
            reply_markup=get_admin_menu_kb()
        )
        return
    
    text = "👥 Последние 10 зарегистрированных пользователей:\n\n"
    
    for user_data in users_info:
        # Определяем тип пользователя
        if user_data.get('user_type') == 'client':
            user_type = "👨‍⚕️ Ветеринар"
        elif user_data.get('user_type') == 'employee':
            user_type = "🔬 Сотрудник"
        else:
            user_type = "👤 Пользователь"
            
        role = " 👑" if user_data['role'] == 'admin' else ""
        
        text += f"{user_type}{role} {user_data.get('name', 'Без имени')}\n"
        text += f"🆔 {user_data['telegram_id']}\n"
        
        if user_data.get('client_code'):
            text += f"🏥 Код: {user_data['client_code']}\n"
        
        if user_data.get('specialization'):
            text += f"📋 Специализация: {user_data['specialization']}\n"
        elif user_data.get('department_function'):
            dept_map = {'laboratory': 'Лаборатория', 'sales': 'Продажи', 'support': 'Поддержка'}
            dept = dept_map.get(user_data['department_function'], user_data['department_function'])
            text += f"🏢 Функция: {dept}\n"
            if user_data.get('region'):
                text += f"📍 Регион: {user_data['region']}\n"
        
        text += f"🌍 Страна: {user_data.get('country', 'BY')}\n"
        text += f"📅 {user_data['registration_date']}\n"
        text += "─" * 30 + "\n"
    
    await message.answer(text, reply_markup=get_admin_menu_kb())

@admin_router.message(F.text == "📋 Все обращения")
async def show_all_requests(message: Message):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    recent_feedback = await db.get_recent_feedback(limit=5)
    
    if not recent_feedback:
        await message.answer(
            "Обращений пока нет.",
            reply_markup=get_admin_menu_kb()
        )
        return
    
    text = "📋 Последние 5 обращений:\n\n"
    
    for feedback in recent_feedback:
        feedback_type = "💡 Предложение" if feedback['feedback_type'] == 'suggestion' else "⚠️ Жалоба"
        status = {
            'new': '🆕 Новое',
            'in_progress': '⏳ В работе',
            'resolved': '✅ Решено'
        }.get(feedback['status'], feedback['status'])
        
        text += f"{feedback_type} | {status}\n"
        text += f"👤 {feedback.get('user_name', 'Неизвестный')}\n"
        text += f"📝 {feedback['message'][:100]}{'...' if len(feedback['message']) > 100 else ''}\n"
        text += f"📅 {feedback['timestamp']}\n"
        text += "─" * 30 + "\n"
    
    await message.answer(text, reply_markup=get_admin_menu_kb())

@admin_router.message(F.text == "🔧 Управление системой")
async def system_management(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    await message.answer(
        "🔧 Управление системой",
        reply_markup=get_system_management_kb()
    )
    await state.set_state(SystemStates.in_system_menu)

@admin_router.message(SystemStates.in_system_menu)
async def handle_system_management(message: Message, state: FSMContext):
    if message.text == "🔙 Назад":
        await state.clear()
        await message.answer("Главное меню администратора", reply_markup=get_admin_menu_kb())
        return
    
    elif message.text == "🔄 Обновить векторную БД":
        loading_msg = await message.answer("⏳ Обновляю векторную базу данных...")
        
        try:
            from src.data_vectorization import DataProcessor
            processor = DataProcessor()
            processor.create_vector_store(reset=True)
            
            await loading_msg.delete()
            await message.answer(
                "✅ Векторная база данных успешно обновлена!",
                reply_markup=get_system_management_kb()
            )
        except Exception as e:
            await loading_msg.delete()
            await message.answer(
                f"❌ Ошибка при обновлении: {str(e)}",
                reply_markup=get_system_management_kb()
            )
    
    elif message.text == "🗑️ Очистить старые логи":
        try:
            cleared_count = await db.clear_old_logs(days=30)
            await message.answer(
                f"✅ Очищено {cleared_count} старых записей логов (старше 30 дней)",
                reply_markup=get_system_management_kb()
            )
        except Exception as e:
            await message.answer(
                f"❌ Ошибка при очистке логов: {str(e)}",
                reply_markup=get_system_management_kb()
            )
    
    elif message.text == "📊 Системная информация":
        try:
            import psutil
            import os
            
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            db_size = os.path.getsize(db.db_path) / 1024 / 1024
            
            vector_db_path = "data/chroma_db"
            vector_db_size = 0
            if os.path.exists(vector_db_path):
                for dirpath, dirnames, filenames in os.walk(vector_db_path):
                    for f in filenames:
                        fp = os.path.join(dirpath, f)
                        vector_db_size += os.path.getsize(fp)
                vector_db_size = vector_db_size / 1024 / 1024
            
            system_info = f"""
📊 Системная информация:

🖥️ Процессор: {cpu_percent}%
💾 Память: {memory.percent}% ({memory.used // 1024 // 1024} МБ / {memory.total // 1024 // 1024} МБ)
💿 Диск: {disk.percent}% ({disk.used // 1024 // 1024 // 1024} ГБ / {disk.total // 1024 // 1024 // 1024} ГБ)

📁 База данных: {db_size:.2f} МБ
🔍 Векторная БД: {vector_db_size:.2f} МБ

🤖 Версия бота: 2.0
📅 Время работы: {await db.get_uptime()}
            """
            
            await message.answer(
                system_info,
                reply_markup=get_system_management_kb()
            )
        except Exception as e:
            await message.answer(
                f"❌ Ошибка при получении информации: {str(e)}",
                reply_markup=get_system_management_kb()
            )
    
    else:
        await message.answer(
            "Выберите действие из меню:",
            reply_markup=get_system_management_kb()
        )


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\feedback.py ###

import re
import asyncio
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_menu_by_role, get_phone_kb, get_feedback_type_kb
from utils.email_sender import send_callback_email, send_feedback_email

from src.database.db_init import db

feedback_router = Router()

class CallbackStates(StatesGroup):
    waiting_for_phone = State()
    waiting_for_message = State()

class FeedbackStates(StatesGroup):
    waiting_for_type = State()
    waiting_for_message = State()

def format_phone_number(phone: str, country: str = 'BY'):
    """Форматирование телефонного номера с учетом страны"""
    digits = re.sub(r'\D', '', phone)
    
    if country == 'BY':
        # Добавляем код страны если его нет
        if len(digits) == 9:
            digits = '375' + digits
        if len(digits) == 12 and digits.startswith('375'):
            return f"+{digits[:3]} ({digits[3:5]}) {digits[5:8]}-{digits[8:10]}-{digits[10:12]}"
    
    elif country == 'RU':
        # Для России
        if len(digits) == 10:
            digits = '7' + digits
        elif len(digits) == 11 and digits.startswith('8'):
            digits = '7' + digits[1:]
        if len(digits) == 11 and digits.startswith('7'):
            return f"+{digits[0]} ({digits[1:4]}) {digits[4:7]}-{digits[7:9]}-{digits[9:11]}"
    
    elif country == 'KZ':
        # Для Казахстана
        if len(digits) == 10 and digits.startswith('7'):
            digits = '7' + digits
        elif len(digits) == 11 and digits.startswith('8'):
            digits = '7' + digits[1:]
        if len(digits) == 11 and digits.startswith('77'):
            return f"+{digits[0]} ({digits[1:4]}) {digits[4:7]}-{digits[7:9]}-{digits[9:11]}"
    elif country == 'AM':
        # Для Армении
        if len(digits) == 8:
            digits = '374' + digits
        if len(digits) == 11 and digits.startswith('374'):
            return f"+{digits[:3]} ({digits[3:5]}) {digits[5:8]}-{digits[8:11]}" 
    return phone  

def validate_phone_number(phone: str, country: str = 'BY'):
    """Валидация телефонного номера с учетом страны"""
    digits = re.sub(r'\D', '', phone)
    
    if country == 'BY':
        # Беларусь: +375 XX XXX-XX-XX
        return bool(re.match(r'^(375)?[0-9]{9}$', digits))
    elif country == 'RU':
        # Россия: +7 XXX XXX-XX-XX
        return bool(re.match(r'^[78]?[0-9]{10}$', digits))
    elif country == 'KZ':
        # Казахстан: +7 7XX XXX-XX-XX
        return bool(re.match(r'^[78]?7[0-9]{9}$', digits))
    elif country == 'AM':
        # Армения: +374 XX XXX-XXX
        return bool(re.match(r'^(374)?[0-9]{8}$', digits))
    return False

@feedback_router.message(F.text == "📞 Заказать звонок")
async def request_callback(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Для использования этой функции необходимо пройти регистрацию.\nИспользуйте команду /start")
        return

    # Получаем страну пользователя
    country = user['country'] if 'country' in user.keys() else 'BY'
    await state.update_data(user_country=country)
    
    # Формируем подсказку по формату
    phone_formats = {
        'BY': "+375 (XX) XXX-XX-XX",
        'RU': "+7 (XXX) XXX-XX-XX",
        'KZ': "+7 (7XX) XXX-XX-XX",
        'AM': "+374 (XX) XXX-XXX"
    }
    
    format_hint = phone_formats.get(country, phone_formats['BY'])
    
    await message.answer(
        f"📞 Заказ обратного звонка\n\n"
        f"Пожалуйста, отправьте ваш номер телефона или введите вручную.\n"
        f"Формат для вашей страны: {format_hint}",
        reply_markup=get_phone_kb()
    )
    await state.set_state(CallbackStates.waiting_for_phone)

@feedback_router.message(CallbackStates.waiting_for_phone)
async def process_phone(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Вернуться в главное меню":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        return

    data = await state.get_data()
    country = data.get('user_country', 'BY')
    phone = ""

    if message.contact:
        phone = message.contact.phone_number
        if not phone.startswith('+'):
            phone = '+' + phone
    else:
        phone = message.text
        if not validate_phone_number(phone, country):
            phone_examples = {
                'BY': "375291234567 или +375 29 123-45-67",
                'RU': "79123456789 или +7 912 345-67-89",
                'KZ': "77012345678 или +7 701 234-56-78",
                'AM': "37477123456 или +374 77 123-456"
            }
            example = phone_examples.get(country, phone_examples['BY'])
            
            await message.answer(
                f"❌ Неверный формат номера телефона.\n"
                f"Пожалуйста, введите номер в формате:\n"
                f"{example}",
                reply_markup=get_phone_kb()
            )
            return
        
        phone = format_phone_number(phone, country)

    await state.update_data(phone=phone)
    await message.answer(
        "Отлично! Теперь напишите ваше сообщение.\n"
        "Опишите причину обращения, удобное время для звонка и любую другую важную информацию:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(CallbackStates.waiting_for_message)

@feedback_router.message(CallbackStates.waiting_for_message)
async def process_callback_message(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Вернуться в главное меню":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        print(f"[INFO] User {user_id} cancelled callback message")
        return

    data = await state.get_data()
    phone = data.get('phone')
    user = await db.get_user(user_id)
    
    # Преобразуем Row в словарь
    user_dict = dict(user) if user else {}

    print(f"[INFO] Sending callback email for user {user_id}")
    email_sent = await send_callback_email(user_dict, phone, message.text)

    if email_sent:
        print(f"[INFO] Callback email sent for user {user_id}")
    else:
        print(f"[WARN] Callback email failed for user {user_id}, fallback to acceptance message")

    await db.add_request_stat(user_id, "callback_request", f"Телефон: {phone}, Сообщение: {message.text[:100]}...")
    print(f"[INFO] Callback stat saved for user {user_id}")

    user_role = user['role'] if user else 'user'
    await message.answer(
        "✅ Ваша заявка на обратный звонок успешно отправлена!\n\n"
        f"📞 Телефон: {phone}\n💬 Сообщение: {message.text}\n\n"
        "Наш специалист свяжется с вами в ближайшее время.",
        reply_markup=get_menu_by_role(user_role)
    )
    await state.clear()
    print(f"[INFO] State cleared for user {user_id}")

@feedback_router.message(F.text == "💡 Предложения и пожелания")
async def start_feedback(message: Message, state: FSMContext):
    user_id = message.from_user.id
    print(f"[INFO] User {user_id} requested feedback submission")

    user = await db.get_user(user_id)
    if not user:
        print(f"[WARN] User {user_id} not registered, prompting /start")
        await message.answer("Для использования этой функции необходимо пройти регистрацию.\nИспользуйте команду /start")
        return

    await message.answer("Выберите тип обращения:", reply_markup=get_feedback_type_kb())
    await state.set_state(FeedbackStates.waiting_for_type)
    print(f"[INFO] State set to waiting_for_type for user {user_id}")

@feedback_router.message(FeedbackStates.waiting_for_type)
async def process_feedback_type(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "🔙 Вернуться в главное меню":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        print(f"[INFO] User {user_id} cancelled feedback type selection")
        return

    if message.text not in ["💡 Предложение", "⚠️ Жалоба"]:
        print(f"[WARN] User {user_id} entered invalid feedback type: {message.text}")
        await message.answer("Пожалуйста, выберите тип обращения из предложенных вариантов.", reply_markup=get_feedback_type_kb())
        return

    feedback_type = "suggestion" if message.text == "💡 Предложение" else "complaint"
    await state.update_data(feedback_type=feedback_type)
    print(f"[INFO] User {user_id} selected feedback type: {feedback_type}")

    await message.answer(
        f"Вы выбрали: {message.text}\n\n"
        "Пожалуйста, опишите ваше обращение подробно:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(FeedbackStates.waiting_for_message)
    print(f"[INFO] State set to waiting_for_message for user {user_id}")

@feedback_router.message(FeedbackStates.waiting_for_message)
async def process_feedback_message(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Вернуться в главное меню":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        print(f"[INFO] User {user_id} cancelled feedback message")
        return

    data = await state.get_data()
    feedback_type = data.get('feedback_type')
    user = await db.get_user(user_id)
    
    # Преобразуем Row в словарь
    user_dict = dict(user) if user else {}

    await db.add_feedback(user_id=user_id, feedback_type=feedback_type, message=message.text)
    print(f"[INFO] Feedback saved to DB for user {user_id}")

    await send_feedback_email(user_dict, feedback_type, message.text)
    print(f"[INFO] Feedback email sent for user {user_id}")

    type_text = "предложение" if feedback_type == "suggestion" else "жалоба"
    user_role = user['role'] if user else 'user'
    await message.answer(
        f"✅ Ваше {type_text} успешно отправлено!\n\n"
        "Мы обязательно рассмотрим ваше обращение и примем необходимые меры.\nСпасибо за обратную связь!",
        reply_markup=get_menu_by_role(user_role)
    )
    await state.clear()
    print(f"[INFO] State cleared for user {user_id}")


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\help.py ###

# bot/handlers/help.py
from aiogram import Router, F
from aiogram.types import Message
from bot.keyboards import get_dialog_kb

help_router = Router()

@help_router.message(F.text == "❓ Помощь по функциям")
async def show_function_help(message: Message):
    """Показывает справку по доступным функциям диалога"""
    help_text = """
    Доступные команды в диалоге:
    
    🔄 Новый вопрос - начать новый диалог с нейросетью
    ❌ Завершить диалог - вернуться в главное меню
    ❓ Помощь по функциям - эта справка
    
    В режиме диалога вы можете:
    • Задавать уточняющие вопросы по предыдущему запросу
    • Получать дополнительную информацию
    • Уточнять детали ответа
    
    Для нового поиска информации используйте "🔄 Новый вопрос"
    """
    await message.answer(help_text, reply_markup=get_dialog_kb())


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\questions.py ###

from aiogram import Router, F
from aiogram.types import Message, BufferedInputFile
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_menu_by_role, get_dialog_kb
from datetime import datetime
from src.database.db_init import db
from src.data_vectorization import DataProcessor
from models.models_init import qwen3_32b_instruct_free as llm
from langchain.schema import SystemMessage, HumanMessage
import pytz
import asyncio
import json
import re
import base64

# GIF file_id для анимации загрузки (опционально)
LOADING_GIF_ID = "CgACAgIAAxkBAAMIaGr_qy1Wxaw2VrBrm3dwOAkYji4AAu54AAKmqHlJAtZWBziZvaA2BA"

questions_router = Router()

class QuestionStates(StatesGroup):
    waiting_for_question = State()
    in_dialog = State()
    
def get_time_based_farewell():
    """Возвращает прощание в зависимости от времени суток"""
    # Устанавливаем часовой пояс для Беларуси/России
    tz = pytz.timezone('Europe/Minsk')
    current_hour = datetime.now(tz).hour
    
    if 4 <= current_hour < 12:
        return "Рад был помочь и хорошего утра ☀️"
    elif 12 <= current_hour < 17:
        return "Рад был помочь и хорошего дня 🤝"
    elif 17 <= current_hour < 22:
        return "Рад был помочь и хорошего вечера 🌆"
    else:
        return "Рад был помочь и доброй ночи 🌙"

@questions_router.message(F.text == "🤖 Задать вопрос ассистенту")
async def start_question(message: Message, state: FSMContext):
    """Begin question flow and reset ephemeral memory buffer."""
    user_id = message.from_user.id
    print(f"[INFO] User {user_id} initiated question flow")

    user = await db.get_user(user_id)
    if not user:
        print(f"[WARN] User {user_id} not registered")
        await message.answer(
            "Для использования этой функции необходимо пройти регистрацию.\n"
            "Используйте команду /start"
        )
        return

    role = user['role'] if 'role' in user else 'staff'
    user_name = user.get('name', 'друг')  # Получаем имя пользователя
    print(f"[INFO] Resolved role for user {user_id}: {role}")

    await db.clear_buffer(user_id)

    prompt = f"Привет, {user_name}, чем могу тебе помочь?"

    await message.answer(prompt, reply_markup=get_cancel_kb())
    await state.set_state(QuestionStates.waiting_for_question)
    print(f"[INFO] State set to waiting_for_question for user {user_id}")

    role = user['role'] if 'role' in user else 'staff'
    user_name = user.get('name', 'друг')  # Получаем имя пользователя
    print(f"[INFO] Resolved role for user {user_id}: {role}")

    await db.clear_buffer(user_id)

    # Изменяем приветствие
    prompt = f"Привет, {user_name}, чем могу тебе помочь?"

    await message.answer(prompt, reply_markup=get_cancel_kb())
    await state.set_state(QuestionStates.waiting_for_question)
    print(f"[INFO] State set to waiting_for_question for user {user_id}")

@questions_router.message(QuestionStates.waiting_for_question)
async def process_question(message: Message, state: FSMContext):
    """Handle user question: update memory, fetch RAG context, ask LLM, update memory."""
    user_id = message.from_user.id
    text = message.text.strip()

    if text == "❌ Отмена":
        await state.clear()
        user = await db.get_user(user_id)
        role = user['role'] if 'role' in user else 'staff'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(role))
        print(f"[INFO] User {user_id} cancelled question")
        return

    user = await db.get_user(user_id)
    role = user['role'] if 'role' in user else 'staff'
    print(f"[INFO] User {user_id} submitted question: {text} (role={role})")

    # Store the original question in the state for follow-ups
    await state.update_data(original_question=text)

    # Отправляем анимированное сообщение о загрузке
    loading_msg = await message.answer_animation(
        animation=LOADING_GIF_ID,
        caption="🤖 Обрабатываю ваш запрос...\n⏳ Анализирую данные..."
    )
    
    # Создаем задачу для анимации загрузки
    animation_task = asyncio.create_task(animate_loading(loading_msg))
    
    try:
        # Process the question with RAG
        answer = await process_user_question(user_id, text, role, is_new_question=True)
        
        # Останавливаем анимацию и удаляем сообщение
        animation_task.cancel()
        try:
            await loading_msg.delete()
        except:
            pass
        
        await message.answer(answer, reply_markup=get_dialog_kb())
        await state.set_state(QuestionStates.in_dialog)
        print(f"[INFO] State set to in_dialog for user {user_id}")
        
    except Exception as e:
        print(f"[ERROR] Error processing question for user {user_id}: {e}")
        animation_task.cancel()
        try:
            await loading_msg.delete()
        except:
            pass
        
        await message.answer(
            "❌ Произошла ошибка при обработке вашего вопроса.\n"
            "Пожалуйста, попробуйте еще раз или обратитесь в поддержку.",
            reply_markup=get_menu_by_role(role)
        )
        await state.clear()

# @questions_router.message(
#     QuestionStates.in_dialog, 
#     F.text.regexp(r'(?i)(фото|покажи|дай).*(контейнер|пробирк|тест|анализ)'),
#     flags={"priority": 10}
# )
# async def send_container_image(message: Message, state: FSMContext):
#     """Send container image when specifically requested."""
#     user_id = message.from_user.id
#     processor = DataProcessor()
#     processor.load_vector_store()
    
#     # Get last question from state
#     data = await state.get_data()
#     question = data.get('original_question', '')
    
#     # Search for relevant test
#     hits = processor.search_test(question, top_k=1)
#     if not hits:
#         await message.answer("Не удалось найти информацию о контейнере.")
#         return
    
#     doc = hits[0][0]  # Get the document from search results
    
#     if 'container_image_base64' not in doc.metadata:
#         await message.answer("Изображение контейнера недоступно для этого теста.")
#         return
    
#     try:
#         image_data = doc.metadata['container_image_base64']
#         if ';base64,' in image_data:
#             image_data = image_data.split(';base64,')[-1]
        
#         image_bytes = base64.b64decode(image_data)
#         await message.answer_photo(
#             BufferedInputFile(image_bytes, "container.jpg"),
#             caption=f"Контейнер для теста: {doc.page_content}"
#         )
#     except Exception as e:
#         await message.answer(f"Ошибка при отправке изображения: {str(e)}")

@questions_router.message(QuestionStates.in_dialog)
async def handle_dialog(message: Message, state: FSMContext):
    """Handle follow-up questions in dialog mode."""
    user_id = message.from_user.id
    text = message.text.strip()

    if text == "❌ Завершить диалог":
        await state.clear()
        user = await db.get_user(user_id)
        role = user['role'] if 'role' in user else 'staff'
        farewell_text = get_time_based_farewell()  # Используем функцию для получения прощания
        await message.answer(farewell_text, reply_markup=get_menu_by_role(role))
        print(f"[INFO] User {user_id} ended dialog")
        return
    
    if text == "🔄 Новый вопрос":
        await db.clear_buffer(user_id)
        await message.answer("Задайте новый вопрос:", reply_markup=get_cancel_kb())
        await state.set_state(QuestionStates.waiting_for_question)
        print(f"[INFO] User {user_id} started new question")
        return

    # Get the original question from the state
    data = await state.get_data()
    original_question = data.get('original_question', '')

    user = await db.get_user(user_id)
    role = user['role'] if 'role' in user else 'staff'
    print(f"[INFO] User {user_id} asked follow-up: {text} (role={role})")

    # Добавляем анимацию загрузки для follow-up вопросов
    loading_msg = await message.answer_animation(
        animation=LOADING_GIF_ID,
        caption="🤖 Обрабатываю ваш запрос...\n⏳ Анализирую данные..."
    )
    
    animation_task = asyncio.create_task(animate_loading(loading_msg))
    
    try:
        # Process follow-up without RAG (reuse original question context)
        answer = await process_user_question(user_id, text, role, is_new_question=False)
        
        # Останавливаем анимацию и удаляем сообщение
        animation_task.cancel()
        try:
            await loading_msg.delete()
        except:
            pass
        
        await message.answer(answer, reply_markup=get_dialog_kb())
        print(f"[INFO] Follow-up answer sent to user {user_id}")
        
    except Exception as e:
        print(f"[ERROR] Error processing follow-up for user {user_id}: {e}")
        animation_task.cancel()
        try:
            await loading_msg.delete()
        except:
            pass
        
        await message.answer(
            "❌ Произошла ошибка при обработке вашего вопроса.\n"
            "Пожалуйста, попробуйте еще раз.",
            reply_markup=get_dialog_kb()
        )
    
async def animate_loading(message: Message):
    """Анимация загрузки через редактирование подписи к GIF"""
    animations = [
        "🤖 Обрабатываю ваш запрос...\n⏳ Анализирую данные...",
        "🤖 Обрабатываю ваш запрос...\n🔍 Поиск в базе знаний...",
        "🤖 Обрабатываю ваш запрос...\n🧠 Формирую ответ...",
        "🤖 Обрабатываю ваш запрос...\n📝 Подготавливаю результат..."
    ]
    
    i = 0
    try:
        while True:
            await asyncio.sleep(2)
            i = (i + 1) % len(animations)
            await message.edit_caption(caption=animations[i])  # Изменено с edit_text на edit_caption
    except asyncio.CancelledError:
        pass
    except Exception:
        pass

async def process_user_question(user_id: int, text: str, role: str, is_new_question: bool) -> str:
    """Process user question and return AI response."""
    await db.add_request_stat(user_id, "question", text[:200])
    await db.add_memory(user_id, 'buffer', f"User: {text}")

    summary = await db.get_latest_summary(user_id) or ""
    buffer = await db.get_buffer(user_id)

    rag_context = ""
    rag_hits = []  # Initialize empty list for follow-ups
    
    if is_new_question:
        processor = DataProcessor()
        processor.load_vector_store()
        rag_hits = processor.search_test(text, top_k=5)

        rag_blocks = []
        for doc, score in rag_hits:
            clean_meta = {k: v for k, v in doc.metadata.items() if k != 'container_image_base64'}
            meta_json = json.dumps(clean_meta, ensure_ascii=False, sort_keys=True)
            rag_blocks.append(f"Тест: {doc.page_content}\nМетаданные: {meta_json}")
        rag_context = "\n\n---\n\n".join(rag_blocks)

    memory_section = ""
    if summary:
        memory_section += f"Сводка предыдущих сообщений: {summary}\n\n"
    if buffer:
        memory_section += "Последние сообщения:\n" + "\n".join(buffer) + "\n\n"

    system_msg = SystemMessage(
        content="Ты — ветеринарный помощник. Используй память и преаналитическую информацию для ответа. Если информации нет - честно скажи об этом. Используй форматирование: **жирный** для важного, _курсив_ для терминов. Будь кратким и профессиональным. Делай приятное оформление для телеграмм. Без использования Markdown"
    )
    user_msg = HumanMessage(
        content=(
            f"{memory_section}"
            f"Контекст преаналитики:\n{rag_context}\n\n"
            f"Вопрос пользователя: {text}\n\n"
            "Ответь на русском языке, кратко и по делу."
        )
    )

    print(f"[INFO] Sending prompt to LLM for user {user_id}")
    response = await llm.agenerate([[system_msg, user_msg]])

    def markdown_to_html(text: str) -> str:
        """Convert basic Markdown to Telegram-compatible HTML."""
        # Bold: **text** -> <b>text</b>
        text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
        # Italic: _text_ -> <i>text</i>
        text = re.sub(r'_(.+?)_', r'<i>\1</i>', text)
        # Code: `text` -> <code>text</code>
        text = re.sub(r'`(.+?)`', r'<code>\1</code>', text)
        return text

    answer = response.generations[0][0].text.strip()
    print(f"[INFO] Received LLM answer for user {user_id}")
    answer = markdown_to_html(answer)  # Convert Markdown to HTML
    print(f"[INFO] Converted Markdown to HTML for user {user_id}")
    await db.add_memory(user_id, 'buffer', f"Bot: {answer}")
    print(f"[INFO] Bot response buffered for user {user_id}")

    return answer


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\registration.py ###

import re
from aiogram import Router, F
from aiogram.types import Message, ReplyKeyboardRemove
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import (
    get_user_type_kb, get_department_function_kb, 
    get_main_menu_kb, get_admin_menu_kb, get_specialization_kb,
    get_region_kb, get_country_kb
)

from src.database.db_init import db

registration_router = Router()

class RegistrationStates(StatesGroup):
    waiting_for_user_type = State()
    waiting_for_country = State()
    # Для клиентов
    waiting_for_client_code = State()
    waiting_for_client_name = State()
    waiting_for_specialization = State()
    waiting_for_custom_specialization = State()
    # Для сотрудников
    waiting_for_region = State()
    waiting_for_custom_region = State()
    waiting_for_employee_name = State()
    waiting_for_department = State()

@registration_router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    user_id = message.from_user.id
    print(f"[INFO] User {user_id} initiated registration")

    await state.clear()
    user_exists = await db.user_exists(user_id)

    if user_exists:
        print(f"[INFO] User {user_id} already registered")
        user = await db.get_user(user_id)
        menu_kb = get_admin_menu_kb() if user['role'] == 'admin' else get_main_menu_kb()
        await message.answer(
            "Вы уже зарегистрированы! 🎉\n"
            "Используйте меню для дальнейшей работы.",
            reply_markup=menu_kb
        )
    else:
        print(f"[INFO] User {user_id} starting new registration")
        await message.answer(
            "Добро пожаловать в бот Лаборатории VET UNION! 🧪\n\n"
            "Для начала работы необходимо пройти регистрацию.\n"
            "Выберите, кто вы:",
            reply_markup=get_user_type_kb()
        )
        await state.set_state(RegistrationStates.waiting_for_user_type)

@registration_router.message(RegistrationStates.waiting_for_user_type)
async def process_user_type(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "👨‍⚕️ Ветеринарный врач клиники-партнера":
        await state.update_data(user_type='client')
    elif message.text == "🔬 Сотрудник VET UNION":
        await state.update_data(user_type='employee')
    else:
        await message.answer(
            "❌ Пожалуйста, выберите из предложенных вариантов",
            reply_markup=get_user_type_kb()
        )
        return
    
    # Переходим к выбору страны
    await message.answer(
        "🌍 В какой стране вы находитесь?",
        reply_markup=get_country_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_country)
    
@registration_router.message(RegistrationStates.waiting_for_country)
async def process_country(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    country_map = {
        "🇧🇾 Беларусь": "BY",
        "🇷🇺 Россия": "RU",
        "🇰🇿 Казахстан": "KZ",
        "🇦🇲 Армения": "AM"
    }
    
    if message.text not in country_map:
        await message.answer(
            "❌ Пожалуйста, выберите страну из предложенных вариантов",
            reply_markup=get_country_kb()
        )
        return
    
    country = country_map[message.text]
    await state.update_data(country=country)
    
    # Продолжаем в зависимости от типа пользователя
    data = await state.get_data()
    
    if data['user_type'] == 'client':
        await message.answer(
            "📝 Регистрация ветеринарного врача\n\n"
            "Введите ваш код клиники:\n"
            "⚠️ Код должен начинаться с 'В+' (например: В+МАКСИМА)\n"
            "💡 Код клиники вы можете получить у представителя VET UNION",
            reply_markup=ReplyKeyboardRemove()
        )
        await state.set_state(RegistrationStates.waiting_for_client_code)
    else:
        # Для сотрудников показываем регионы выбранной страны
        await message.answer(
            "📝 Регистрация сотрудника VET UNION\n\n"
            "Выберите ваш регион:",
            reply_markup=get_region_kb(country)
        )
        await state.set_state(RegistrationStates.waiting_for_region)

# Обработчики для клиентов
@registration_router.message(RegistrationStates.waiting_for_client_code)
async def process_client_code(message: Message, state: FSMContext):
    user_id = message.from_user.id
    code = message.text.strip().upper()

    if len(code) < 3 or len(code) > 20 or not re.match(r'^[ВB]\+[А-ЯA-Z0-9\-]+$', code):
        await message.answer(
            "❌ Неверный формат кода клиники.\n\n"
            "Код должен:\n"
            "• Начинаться с 'В+'\n"
            "• Содержать только заглавные буквы и цифры\n"
            "• Пример: В+МАКСИМА\n\n"
            "Попробуйте еще раз:"
        )
        return

    await state.update_data(client_code=code)
    await message.answer(
        f"✅ Код клиники: {code}\n\n"
        "Теперь введите ваше имя:",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.set_state(RegistrationStates.waiting_for_client_name)

@registration_router.message(RegistrationStates.waiting_for_client_name)
async def process_client_name(message: Message, state: FSMContext):
    name = message.text.strip()

    if len(name) < 2 or len(name) > 50:
        await message.answer(
            "❌ Имя должно содержать от 2 до 50 символов.\nПопробуйте еще раз:"
        )
        return

    await state.update_data(name=name)
    await message.answer(
        f"👤 Имя: {name}\n\n"
        "Выберите вашу специализацию:",
        reply_markup=get_specialization_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_specialization)

@registration_router.message(RegistrationStates.waiting_for_specialization)
async def process_specialization(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "✏️ Ввести свою специализацию":
        await message.answer(
            "Введите вашу специализацию:",
            reply_markup=ReplyKeyboardRemove()
        )
        await state.set_state(RegistrationStates.waiting_for_custom_specialization)
        return
    
    specialization_map = {
        "🏥 Общая практика": "Общая практика",
        "🔪 Хирургия": "Хирургия",
        "💊 Терапия": "Терапия",
        "🦴 Ортопедия": "Ортопедия",
        "🎗️ Онкология": "Онкология",
        "🦠 Дерматология": "Дерматология",
        "👁️ Офтальмология": "Офтальмология",
        "🦷 Стоматология": "Стоматология"
    }
    
    if message.text not in specialization_map:
        await message.answer(
            "❌ Пожалуйста, выберите специализацию из списка или введите свою",
            reply_markup=get_specialization_kb()
        )
        return
    
    specialization = specialization_map[message.text]
    data = await state.get_data()
    
    success = await db.add_client(
        telegram_id=user_id,
        name=data['name'],
        client_code=data['client_code'],
        specialization=specialization,
        country=data.get('country', 'BY')
    )

    if success:
        await message.answer(
            f"✅ Регистрация завершена успешно!\n\n"
            f"👤 Имя: {data['name']}\n"
            f"🏥 Код клиники: {data['client_code']}\n"
            f"📋 Специализация: {specialization}\n"
            f"🌍 Страна: {message.text.split()[1] if data['country'] == 'BY' else message.text.split()[1]}\n\n"
            "Теперь вы можете пользоваться всеми функциями бота!",
            reply_markup=get_main_menu_kb()
        )
    else:
        await message.answer(
            "❌ Ошибка регистрации. Возможно, вы уже зарегистрированы.\nПопробуйте еще раз: /start",
            reply_markup=ReplyKeyboardRemove()
        )

    await state.clear()

@registration_router.message(RegistrationStates.waiting_for_custom_specialization)
async def process_custom_specialization(message: Message, state: FSMContext):
    user_id = message.from_user.id
    specialization = message.text.strip()

    if len(specialization) < 2 or len(specialization) > 100:
        await message.answer(
            "❌ Специализация должна содержать от 2 до 100 символов.\nПопробуйте еще раз:"
        )
        return

    data = await state.get_data()
    
    success = await db.add_client(
        telegram_id=user_id,
        name=data['name'],
        client_code=data['client_code'],
        specialization=specialization,
        country=data.get('country', 'BY')
    )

    if success:
        await message.answer(
            f"✅ Регистрация завершена успешно!\n\n"
            f"👤 Имя: {data['name']}\n"
            f"🏥 Код клиники: {data['client_code']}\n"
            f"📋 Специализация: {specialization}\n\n"
            "Теперь вы можете пользоваться всеми функциями бота!",
            reply_markup=get_main_menu_kb()
        )
    else:
        await message.answer(
            "❌ Ошибка регистрации. Возможно, вы уже зарегистрированы.\nПопробуйте еще раз: /start",
            reply_markup=ReplyKeyboardRemove()
        )

    await state.clear()

# Обработчики для сотрудников
@registration_router.message(RegistrationStates.waiting_for_region)
async def process_region(message: Message, state: FSMContext):
    if message.text == "✏️ Ввести свой регион":
        await message.answer(
            "Введите ваш регион:",
            reply_markup=ReplyKeyboardRemove()
        )
        await state.set_state(RegistrationStates.waiting_for_custom_region)
        return
    
    # Получаем данные из state
    data = await state.get_data()
    
    # Проверяем, что выбран регион из клавиатуры
    if not message.text.startswith("📍"):
        await message.answer(
            "❌ Пожалуйста, выберите регион из списка или введите свой",
            reply_markup=get_region_kb(data.get('country', 'BY'))
        )
        return
    
    region = message.text.replace("📍 ", "")
    await state.update_data(region=region)
    await message.answer(
        f"📍 Регион: {region}\n\n"
        "Введите вашу фамилию и имя:",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.set_state(RegistrationStates.waiting_for_employee_name)

@registration_router.message(RegistrationStates.waiting_for_custom_region)
async def process_custom_region(message: Message, state: FSMContext):
    region = message.text.strip()

    if len(region) < 2 or len(region) > 100:
        await message.answer(
            "❌ Регион должен содержать от 2 до 100 символов.\nПопробуйте еще раз:"
        )
        return

    await state.update_data(region=region)
    await message.answer(
        f"📍 Регион: {region}\n\n"
        "Введите вашу фамилию и имя:",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.set_state(RegistrationStates.waiting_for_employee_name)

@registration_router.message(RegistrationStates.waiting_for_employee_name)
async def process_employee_name(message: Message, state: FSMContext):
    name = message.text.strip()

    if len(name) < 3 or len(name) > 100:
        await message.answer(
            "❌ ФИО должно содержать от 3 до 100 символов.\nПопробуйте еще раз:"
        )
        return

    await state.update_data(name=name)
    await message.answer(
        f"👤 ФИО: {name}\n\n"
        "Выберите функцию, которую вы исполняете:",
        reply_markup=get_department_function_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_department)

@registration_router.message(RegistrationStates.waiting_for_department)
async def process_department(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    department_map = {
        "🔬 Лаборатория": "laboratory",
        "💰 Продажи": "sales",
        "🤝 Поддержка": "support"
    }

    if message.text not in department_map:
        await message.answer(
            "❌ Пожалуйста, выберите функцию из предложенных вариантов",
            reply_markup=get_department_function_kb()
        )
        return

    data = await state.get_data()
    
    success = await db.add_employee(
        telegram_id=user_id,
        name=data['name'],
        region=data['region'],
        department_function=department_map[message.text],
        country=data['country']
    )

    if success:
        await message.answer(
            f"✅ Регистрация завершена успешно!\n\n"
            f"👤 ФИО: {data['name']}\n"
            f"📍 Регион: {data['region']}\n"
            f"🏢 Функция: {message.text}\n\n"
            "Теперь вы можете пользоваться всеми функциями бота!",
            reply_markup=get_main_menu_kb()
        )
    else:
        await message.answer(
            "❌ Ошибка регистрации. Попробуйте еще раз: /start",
            reply_markup=ReplyKeyboardRemove()
        )

    await state.clear()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\bot\handlers\__init__.py ###

from aiogram import Bot, Dispatcher
from aiogram.enums.parse_mode import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.memory import MemoryStorage

from bot.handlers.registration import registration_router
from bot.handlers.feedback import feedback_router
from bot.handlers.activation import activation_router
from bot.handlers.questions import questions_router
from bot.handlers.admin import admin_router
from bot.handlers.help import help_router
from config import BOT_API_KEY

if not BOT_API_KEY:
    raise RuntimeError('BOT_API_KEY not found.')

bot = Bot(
    token=BOT_API_KEY, 
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher(storage=MemoryStorage())
dp.include_router(registration_router)
dp.include_router(feedback_router)
dp.include_router(activation_router)
dp.include_router(questions_router)
dp.include_router(admin_router)
dp.include_router(help_router)


### FILE: C:\Users\Legion\AI_VET_Assistant-2\junk\data_preprocessing.py ###

import pandas as pd
from pathlib import Path

def process_excel_file():
    input_path = Path('data/raw/Преаналитика и локализации.xlsx')
    output_path = Path('data/processed/preanalytics_data.xlsx')

    expected_columns = [
        'Код теста', 'Название теста', 'Время голодания',
        'Исследуемый биоматериал', 'Номер контейнера/пробирки/пробирки',
        'Важные ПРЕАНАЛИТИЧЕСКИЕ замечания к тесту к тесту',
        'Тип ПЕРВИЧНОГО контейнера',
        'Тип контейнера для ХРАНЕНИЯ и ТРАНСПОРТИРОВКИ',
        'Температура хранения и транспортировки',
        'Правила взятия и пробоподготовки биоматериала',
        'напрвление исследования'
    ]

    column_rename_map = {
        'Код теста': 'test_code',
        'Название теста': 'test_name',
        'Время голодания': 'fasting_time',
        'Исследуемый биоматериал': 'biomaterial',
        'Номер контейнера/пробирки/пробирки': 'container_id',
        'Важные ПРЕАНАЛИТИЧЕСКИЕ замечания к тесту к тесту': 'preanalytical_notes',
        'Тип ПЕРВИЧНОГО контейнера': 'primary_container',
        'Тип контейнера для ХРАНЕНИЯ и ТРАНСПОРТИРОВКИ': 'storage_transport_container',
        'Температура хранения и транспортировки': 'storage_temperature',
        'Правила взятия и пробоподготовки биоматериала': 'collection_rules',
        'напрвление исследования': 'research_direction'
    }

    xls = pd.ExcelFile(input_path)
    sheets_to_process = [s for s in xls.sheet_names if s != 'Первый лист']

    df_list = []

    for sheet in sheets_to_process:
        df = pd.read_excel(xls, sheet_name=sheet)

        research_col = None
        for col in df.columns:
            if col.strip().lower() == 'исследование':
                research_col = col
                break

        for col in expected_columns:
            if col not in df.columns:
                df[col] = pd.NA

        df = df[expected_columns]
        df = df.rename(columns=column_rename_map)

        if research_col:
            print(f'[INFO] Found extra column "{research_col}" in sheet "{sheet}"')
            alt_names = pd.read_excel(xls, sheet_name=sheet)[research_col].fillna('')
            for i in df.index:
                name = str(df.at[i, 'test_name']) if pd.notna(df.at[i, 'test_name']) else ''
                alt = str(alt_names.iloc[i]).strip()
                if len(alt) > len(name):
                    df.at[i, 'test_name'] = alt

        df['source_sheet'] = sheet
        df_list.append(df)

    combined_df = pd.concat(df_list, ignore_index=True)
    combined_df.dropna(subset=['test_code', 'test_name'], inplace=True)
    combined_df = combined_df[~combined_df['test_name'].astype(str).str.lower().eq('nan')]
    df_unique_code = combined_df.drop_duplicates(subset=['test_code'])
    df_unique_name = combined_df.drop_duplicates(subset=['test_name'])
    combined_df = df_unique_code[df_unique_code.index.isin(df_unique_name.index)]
    output_path.parent.mkdir(parents=True, exist_ok=True)
    combined_df.to_excel(output_path, index=False)
    print(f'[INFO] Saved processed data to {output_path}')

if __name__ == '__main__':
    process_excel_file()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\models\models_init.py ###

from langchain_community.chat_models import ChatOpenAI

from config import OPENROUTER_API_KEY

MAX_URLS = 5

SEED = 0
TEMPERATURE = 0.7
TOP_P = 1.0


if not OPENROUTER_API_KEY:
    raise RuntimeError('OPENROUTER_API_KEY not found.')

def make_chat(model_name: str, streaming: bool = True) -> ChatOpenAI:
    """
    Helper to instantiate ChatOpenAI with correct kwargs
    """
    return ChatOpenAI(
        model=model_name,
        openai_api_key=OPENROUTER_API_KEY,
        openai_api_base="https://openrouter.ai/api/v1",
        temperature=TEMPERATURE,
        streaming=streaming,
        model_kwargs={"top_p": TOP_P, "seed": SEED},
    )

# FREE models
qwen_coder_32b_instruct_free = make_chat("qwen/qwen-2.5-coder-32b-instruct:free")
qwen3_32b_instruct_free = make_chat("qwen/qwen3-32b:free")
gemma3_27b_instruct_free = make_chat("google/gemma-3-27b-it:free")
qwq_32b_instruct_free = make_chat("qwen/qwq-32b:free")
deepseek_r1_instruct_free = make_chat("deepseek/deepseek-r1:free")
gemini_2_5_pro_exp_free = make_chat("google/gemini-2.5-pro-exp-03-25:free")

# PAYABLE models
gpt_4o = make_chat("openai/gpt-4o", streaming=False)
openai_o1 = make_chat("openai/o1", streaming=False)
openai_o3_mini_high = make_chat("openai/o3-mini-high", streaming=False)
openai_o3_mini = make_chat("openai/o3-mini", streaming=False)
openai_o3 = make_chat("openai/o3", streaming=False)
openai_o1_pro = make_chat("openai/o1-pro", streaming=False)
openai_o1_mini = make_chat("openai/o1-mini", streaming=False)
openai_gpt_4o_search_preview = make_chat("openai/gpt-4o-search-preview", streaming=False)


# additional interesting params (for LLMs)

# max_retries=3,
# max_tokens=150,
# logit_bias={50256: -10}, # (token_id→bias)
# reasoning_effort={"analysis": "high", "summary": "low"},  # max analysis min summary
# cache=None,
# request_timeout=(5.0, 15.0), # (connect, read), sec


### FILE: C:\Users\Legion\AI_VET_Assistant-2\models\vector_models_init.py ###

import torch
import torch.nn.functional as F
from transformers import AutoTokenizer, AutoModel
from langchain_core.embeddings import Embeddings
from openai import OpenAI
from typing import List
from torch import Tensor
from tqdm import tqdm
import numpy as np

from config import DEEPINFRA_API_KEY

# Device selection
if torch.cuda.is_available():
    device = torch.device('cuda')
elif torch.backends.mps.is_available():
    device = torch.device('mps')
    torch.mps.set_per_process_memory_fraction(0.9)
    torch.mps.empty_cache()
else:
    device = torch.device('cpu')


def get_detailed_instruct(task_description: str, query: str) -> str:
    return f'Instruct: {task_description}\nQuery: {query}'

task_prompt = (
    "You are an embedding model specialized in mapping veterinary "
    "pre-analytical and diagnostic questions to laboratory test names. "
    "Embed the query so that it best matches the correct test title."
)

class QwenEmbeddings(Embeddings):
    def __init__(
        self,
        model_name: str = 'Qwen/Qwen3-Embedding-4B',
        task_prompt: str = task_prompt,
        max_length: int = 8192,
        batch_size: int = 8,
        use_remote: bool = None
    ):
        self.model_name = model_name
        self.task_prompt = task_prompt
        self.max_length = max_length
        self.batch_size = batch_size
        # Determine remote vs local
        if use_remote is None:
            self.use_remote = bool(DEEPINFRA_API_KEY)
        else:
            self.use_remote = use_remote

        if self.use_remote:
            api_key = DEEPINFRA_API_KEY
            if not api_key:
                raise ValueError('DEEPINFRA_API_KEY not set for remote embeddings')
            self.client = OpenAI(
                api_key=api_key,
                base_url='https://api.deepinfra.com/v1/openai'
            )
            print(f'[INFO] Using DeepInfra remote embeddings for model: {model_name}')
        else:
            print(f'[INFO] Using local embeddings for model: {model_name} on device: {device}')
            self.device = device
            self.tokenizer = AutoTokenizer.from_pretrained(model_name, padding_side='left')
            if self.device == torch.device('cuda'):
                self.model = AutoModel.from_pretrained(
                    model_name,
                    attn_implementation='flash_attention_2',
                    torch_dtype=torch.float16,
                    device_map='auto'
                )
            else:
                self.model = AutoModel.from_pretrained(model_name)
                self.model.to(self.device)
            self.model.eval()

    def last_token_pool(self, last_hidden_states: Tensor, attention_mask: Tensor) -> Tensor:
        # same pooling logic
        left_padding = (attention_mask[:, -1].sum() == attention_mask.shape[0])
        if left_padding:
            return last_hidden_states[:, -1]
        else:
            seq_lens = attention_mask.sum(dim=1) - 1
            batch_size = last_hidden_states.shape[0]
            return last_hidden_states[
                torch.arange(batch_size, device=last_hidden_states.device), seq_lens
            ]

    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        return self._encode(texts)

    def embed_query(self, text: str) -> List[float]:
        prompt = get_detailed_instruct(self.task_prompt, text)
        return self._encode([prompt])[0]

    def _encode(self, texts: List[str]) -> List[List[float]]:
        results: List[List[float]] = []
        if self.use_remote: # Remote embedding via DeepInfra/OpenAI client
            batch_size = 200
            for i in tqdm(range(0, len(texts), batch_size), desc='Remote embedding batches'):
                batch_texts = texts[i:i + batch_size]
                # print(f'[INFO] Sending remote batch of size {len(batch_texts)}')
                response = self.client.embeddings.create(
                    model=self.model_name,
                    input=batch_texts,
                    encoding_format='float'
                )
                # Collect embeddings
                vecs = [d.embedding for d in response.data]
                # Normalize
                arr = np.array(vecs, dtype=float)
                norms = np.linalg.norm(arr, axis=1, keepdims=True)
                arr = arr / norms
                results.extend(arr.tolist())
            return results
        else: # Local embedding
            batch_size = self.batch_size
            for i in tqdm(range(0, len(texts), batch_size), desc='Local embedding batches'):
                batch_texts = texts[i:i + batch_size]
                batch = self.tokenizer(
                    batch_texts,
                    padding=True,
                    truncation=True,
                    max_length=self.max_length,
                    return_tensors='pt'
                ).to(self.model.device)

                with torch.no_grad():
                    outputs = self.model(**batch)
                    embeddings = self.last_token_pool(outputs.last_hidden_state, batch['attention_mask'])
                    embeddings = F.normalize(embeddings, p=2, dim=1)

                results.extend(embeddings.cpu().tolist())
            return results


# Instantiate default embedding model (auto-detect)
embedding_model = QwenEmbeddings(model_name='Qwen/Qwen3-Embedding-0.6B', task_prompt=task_prompt, use_remote=True)


### FILE: C:\Users\Legion\AI_VET_Assistant-2\models\__init__.py ###



### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\check.py ###

from langchain_community.vectorstores import Chroma
from models.vector_models_init import embedding_model

def main():
    persist_path = "data/chroma_db"

    print(f"[INFO] Loading vector store from {persist_path}")
    vector_store = Chroma(
        embedding_function=embedding_model,
        persist_directory=persist_path
    )

    # Получаем количество документов в векторной базе
    collection = vector_store._collection  # Access underlying chromadb Collection object
    count = collection.count()

    print(f"[INFO] Number of documents in vector store: {count}")

if __name__ == "__main__":
    main()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\data_vectorization.py ###

import os
os.environ['ANONYMIZED_TELEMETRY'] = 'False'
import shutil
import sys
from pathlib import Path
import pandas as pd
from langchain_community.vectorstores import Chroma

project_root = Path(__file__).resolve().parents[1]
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from models.vector_models_init import embedding_model


class DataProcessor:
    def __init__(self, file_path: str = 'data/processed/data.xlsx'):
        self.file_path = Path(file_path)
        self.df = None
        self.vector_store = None
        self.embeddings = embedding_model

    def load_data(self) -> pd.DataFrame:
        if not self.file_path.exists():
            raise FileNotFoundError(f'[ERROR] File not found: {self.file_path}')
        
        print(f'[INFO] Loading data from {self.file_path}')
        self.df = pd.read_excel(self.file_path)
        print(f'[INFO] Loaded {len(self.df)} rows')
        return self.df

    def create_vector_store(self, persist_path: str = "data/chroma_db", reset: bool = False) -> Chroma:
        if self.df is None:
            self.load_data()

        if reset and Path(persist_path).exists():
            print(f'[INFO] Resetting vector store at {persist_path}')
            shutil.rmtree(persist_path)

        print('[INFO] Creating vector store...')
        records = self.df.dropna(subset=["test_name"]).copy()

        texts = records["test_name"].tolist()
        metadatas = records.to_dict(orient="records")

        self.vector_store = Chroma.from_texts(
            texts=texts,
            embedding=self.embeddings,
            metadatas=metadatas,
            persist_directory=persist_path,
            collection_metadata={"hnsw:space": "cosine"}
        )
        self.vector_store.persist()
        print(f'[INFO] Vector store created and persisted at {persist_path}')
        return self.vector_store

    def save_vector_store(self, path: str = "data/chroma_db"):
        if self.vector_store is None:
            raise ValueError("Vector store has not been created yet.")
        self.vector_store.persist()
        print(f'[INFO] Vector store saved to {path}')

    def load_vector_store(self, path: str = "data/chroma_db"):
        print(f'[INFO] Loading vector store from {path}')
        self.vector_store = Chroma(
            embedding_function=self.embeddings,
            persist_directory=path
        )
        return self.vector_store

    def search_test(self, query: str, top_k: int = 3):
        if self.vector_store is None:
            if not self.load_vector_store():
                self.create_vector_store()
        print(f'[INFO] Searching for: "{query}"')
        results = self.vector_store.similarity_search_with_score(query, k=top_k)
        return results
    
    def get_metadata_columns(self) -> list:
        """Get list of metadata columns stored in vector database."""
        if self.vector_store is None:
            self.load_vector_store()
        
        # Get sample document to extract metadata keys
        sample = self.vector_store.get()['metadatas'][0] if self.vector_store.get()['metadatas'] else {}
        return list(sample.keys())


if __name__ == "__main__":
    processor = DataProcessor(file_path='data/processed/data.xlsx')
    processor.create_vector_store(persist_path="data/chroma_db", reset=True)
    print("[INFO] Vector store successfully created and saved.")


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\search_test.py ###

import sys
import json

from data_vectorization import DataProcessor

def main():
    if len(sys.argv) < 2:
        print("Usage: python search_test.py 'your query here'")
        return

    query = " ".join(sys.argv[1:])
    print(f'Query: "{query}"')
    processor = DataProcessor()
    processor.load_vector_store()

    results = processor.search_test(query, top_k=3)
    print("\nTop results:")
    for doc, score in results:
        print(f"- Score: {score:.4f} \nText: {doc.page_content} \nMetadata:")
        print(json.dumps(doc.metadata, ensure_ascii=False, indent=4, sort_keys=True))
        print("\n")

if __name__ == "__main__":
    main()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\show_metadata_columns.py ###

from data_vectorization import DataProcessor

def main():
    processor = DataProcessor(file_path='data/processed/data.xlsx')
    processor.load_vector_store() 
    
    columns = processor.get_metadata_columns()
    print("Столбцы метаданных в Chroma:")
    for col in columns:
        print(f"- {col}")

if __name__ == "__main__":
    main()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\database\db_init.py ###

from .models import Database

db = Database('data/vet_clinic.db')


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\database\images_to_base64_match.py ###

import openpyxl
import pandas as pd
import base64
import io
from PIL import Image as PILImage
from pathlib import Path

def extract_images_from_reference_sheet(file_path, sheet_name="Справочник пробирок"):
    """
    Извлекает изображения из листа 'Справочник пробирок' и создает словарь 
    соответствий между типами контейнеров и base64 изображениями
    """
    # Загружаем рабочую книгу
    workbook = openpyxl.load_workbook(file_path)
    worksheet = workbook[sheet_name]
    
    # Словарь для хранения соответствий
    image_dict = {}
    
    # Читаем типы контейнеров из столбца A (начиная со строки 2)
    container_types = {}
    for row in range(2, worksheet.max_row + 1):
        cell_value = worksheet[f'A{row}'].value
        if cell_value and cell_value.strip():
            container_types[row] = cell_value.strip()
    
    print(f"Найдено типов контейнеров: {len(container_types)}")
    for row, container_type in container_types.items():
        print(f"  Строка {row}: {container_type}")
    
    # Получаем все изображения из листа
    images = worksheet._images
    print(f"Найдено изображений в листе: {len(images)}")
    
    # Обрабатываем каждое изображение
    for img_idx, img in enumerate(images):
        try:
            # Получаем позицию изображения
            if hasattr(img.anchor, '_from'):
                # Для newer versions of openpyxl
                row_idx = img.anchor._from.row + 1
                col_idx = img.anchor._from.col + 1
            else:
                # Для older versions
                row_idx = img.anchor.row if hasattr(img.anchor, 'row') else 1
                col_idx = img.anchor.col if hasattr(img.anchor, 'col') else 1
            
            print(f"Изображение {img_idx + 1}: позиция строка {row_idx}, столбец {col_idx}")
            
            # Находим ближайший тип контейнера
            container_type = None
            min_distance = float('inf')
            
            for row_num, c_type in container_types.items():
                distance = abs(row_num - row_idx)
                if distance < min_distance:
                    min_distance = distance
                    container_type = c_type
            
            if container_type and min_distance <= 2:  # Допускаем погрешность в 2 строки
                try:
                    # Получаем данные изображения
                    # img.ref может быть BytesIO объектом или байтами
                    if hasattr(img.ref, 'read'):
                        # Если это BytesIO объект
                        img.ref.seek(0)  # Переходим к началу
                        img_data = img.ref.read()
                    else:
                        # Если это уже байты
                        img_data = img.ref
                    
                    # Конвертируем в PIL Image и затем в base64
                    pil_image = PILImage.open(io.BytesIO(img_data))
                    
                    # Изменяем размер изображения для оптимизации (опционально)
                    max_size = (300, 300)
                    pil_image.thumbnail(max_size, PILImage.Resampling.LANCZOS)
                    
                    # Конвертируем в base64
                    buffered = io.BytesIO()
                    pil_image.save(buffered, format="PNG")
                    img_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                    
                    image_dict[container_type] = img_base64
                    print(f"  Сопоставлено: {container_type} -> изображение {len(img_base64)} символов")
                    
                except Exception as e:
                    print(f"  Ошибка при обработке изображения для {container_type}: {e}")
                    # Попробуем альтернативный способ извлечения
                    try:
                        # Альтернативный способ - через _data атрибут
                        if hasattr(img, '_data'):
                            img_data = img._data
                        elif hasattr(img, 'path'):
                            # Если изображение хранится как файл
                            with open(img.path, 'rb') as f:
                                img_data = f.read()
                        else:
                            print(f"  Не удалось найти данные изображения для {container_type}")
                            continue
                            
                        pil_image = PILImage.open(io.BytesIO(img_data))
                        max_size = (300, 300)
                        pil_image.thumbnail(max_size, PILImage.Resampling.LANCZOS)
                        
                        buffered = io.BytesIO()
                        pil_image.save(buffered, format="PNG")
                        img_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                        
                        image_dict[container_type] = img_base64
                        print(f"  Сопоставлено (альтернативный способ): {container_type} -> изображение {len(img_base64)} символов")
                        
                    except Exception as e2:
                        print(f"  Альтернативный способ тоже не сработал для {container_type}: {e2}")
                        continue
            else:
                print(f"  Не найден подходящий тип контейнера для изображения на позиции {row_idx}")
                
        except Exception as e:
            print(f"Ошибка при обработке изображения {img_idx + 1}: {e}")
            continue
    
    workbook.close()
    return image_dict

def find_matching_image(container_type, image_dict):
    """
    Находит подходящее изображение по вхождению названия
    """
    if not container_type or pd.isna(container_type):
        return None
        
    container_type_clean = str(container_type).strip().lower()
    
    # Сначала ищем точное совпадение
    for ref_type, base64_img in image_dict.items():
        if container_type_clean == ref_type.lower().strip():
            return base64_img
    
    # Затем ищем по вхождению - название из data входит в название из справочника
    for ref_type, base64_img in image_dict.items():
        ref_type_clean = ref_type.lower().strip()
        if container_type_clean in ref_type_clean:
            return base64_img
    
    # Затем ищем обратное вхождение - название из справочника входит в название из data
    for ref_type, base64_img in image_dict.items():
        ref_type_clean = ref_type.lower().strip()
        if ref_type_clean in container_type_clean:
            return base64_img
    
    # Ищем по ключевым словам
    keywords_mapping = {
        'белая': ['белая', 'белой'],
        'красная': ['красная', 'красной', 'гель', 'гелем'],
        'сиреневая': ['сиреневая', 'сиреневой', 'розовая', 'розовой', 'эдта'],
        'желтая': ['желтая', 'желтой', 'моча', 'мочи', 'консервант'],
        'стерильный': ['стерильный', 'стерильной', 'спирт'],
        'кал': ['кал', 'кала', 'ложечка', 'ложечкой'],
        'микро': ['микро', 'транспорт'],
        'стекло': ['стекло', 'предметное'],
        'флакон': ['флакон', 'юнона', 'детский'],
        'amies': ['amies', 'оранжевая', 'оранжевой'],
        'гистолог': ['гистолог', 'histopot'],
        'парафин': ['парафин', 'блок']
    }
    
    for ref_type, base64_img in image_dict.items():
        ref_type_clean = ref_type.lower().strip()
        for keyword, synonyms in keywords_mapping.items():
            if any(syn in container_type_clean for syn in synonyms) and keyword in ref_type_clean:
                return base64_img
    
    return None

def add_base64_to_data_sheet(file_path, image_dict, data_sheet="data"):
    """
    Добавляет столбец с base64 изображениями в лист 'data'
    """
    # Читаем данные из листа 'data'
    df = pd.read_excel(file_path, sheet_name=data_sheet)
    
    print(f"Загружено строк данных: {len(df)}")
    print(f"Столбцы: {list(df.columns)}")
    
    # Создаем новый столбец с base64 изображениями используя функцию поиска по вхождению
    df['container_image_base64'] = df['container_type'].apply(lambda x: find_matching_image(x, image_dict))
    
    # Проверяем результат
    matched = df['container_image_base64'].notna().sum()
    total = len(df)
    print(f"Сопоставлено изображений: {matched} из {total}")
    
    # Показываем детальную статистику сопоставления
    print("\nДетальная статистика сопоставления:")
    container_counts = df['container_type'].value_counts()
    for container_type, count in container_counts.items():
        matched_image = find_matching_image(container_type, image_dict)
        if matched_image:
            # Находим какое именно изображение было сопоставлено
            matched_ref_type = None
            for ref_type, base64_img in image_dict.items():
                if base64_img == matched_image:
                    matched_ref_type = ref_type
                    break
            print(f"  ✓ '{container_type}' -> '{matched_ref_type}' ({count} записей)")
        else:
            print(f"  ✗ '{container_type}' -> НЕ НАЙДЕНО ({count} записей)")
    
    # Сохраняем обновленный файл
    with pd.ExcelWriter(file_path, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
        df.to_excel(writer, sheet_name=data_sheet, index=False)
    
    print(f"\nДанные сохранены в лист '{data_sheet}' с новым столбцом 'container_image_base64'")
    
    return df

def verify_base64_images(df, column='container_image_base64'):
    """
    Проверяет корректность base64 изображений
    """
    print(f"\nПроверка base64 изображений в столбце '{column}':")
    
    valid_count = 0
    invalid_count = 0
    
    for index, row in df.iterrows():
        base64_str = row[column] if column in row else None
        if pd.notna(base64_str) and isinstance(base64_str, str):
            try:
                # Пытаемся декодировать base64
                img_data = base64.b64decode(base64_str)
                
                # Проверяем, что это действительно изображение
                img = PILImage.open(io.BytesIO(img_data))
                valid_count += 1
                
                if index < 5:  # Показываем детали для первых 5 изображений
                    print(f"  Строка {index + 1}: ✓ {img.size} пикселей, формат {img.format}")
                    
            except Exception as e:
                invalid_count += 1
                print(f"  Строка {index + 1}: ✗ Ошибка: {e}")
    
    print(f"\nИтого: {valid_count} корректных изображений, {invalid_count} с ошибками")

# Альтернативная функция для извлечения изображений
def extract_images_alternative_approach(file_path, sheet_name="Справочник пробирок"):
    """
    Альтернативный подход к извлечению изображений - 
    сохраняем Excel как zip и извлекаем изображения из media папки
    """
    import zipfile
    import tempfile
    import os
    import shutil
    
    # Создаем временную папку
    with tempfile.TemporaryDirectory() as temp_dir:
        # Копируем Excel файл как zip
        zip_path = os.path.join(temp_dir, "excel_file.zip")
        shutil.copy2(file_path, zip_path)
        
        try:
            # Извлекаем zip архив
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(temp_dir)
            
            # Ищем папку с изображениями
            media_path = os.path.join(temp_dir, "xl", "media")
            if not os.path.exists(media_path):
                print("Папка с изображениями не найдена")
                return {}
            
            # Загружаем типы контейнеров из Excel
            df_ref = pd.read_excel(file_path, sheet_name=sheet_name)
            container_types = df_ref['Тип контейнера для хранения и транспортировки'].dropna().tolist()
            
            # Получаем все файлы изображений
            image_files = [f for f in os.listdir(media_path) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp'))]
            image_files.sort()  # Сортируем по имени файла
            
            print(f"Найдено файлов изображений: {len(image_files)}")
            print(f"Типов контейнеров: {len(container_types)}")
            
            image_dict = {}
            
            # Сопоставляем изображения с типами контейнеров по порядку
            for i, (image_file, container_type) in enumerate(zip(image_files, container_types)):
                try:
                    image_path = os.path.join(media_path, image_file)
                    
                    # Читаем изображение
                    with open(image_path, 'rb') as f:
                        img_data = f.read()
                    
                    # Конвертируем в PIL Image
                    pil_image = PILImage.open(io.BytesIO(img_data))
                    
                    # Изменяем размер для оптимизации
                    max_size = (300, 300)
                    pil_image.thumbnail(max_size, PILImage.Resampling.LANCZOS)
                    
                    # Конвертируем в base64
                    buffered = io.BytesIO()
                    pil_image.save(buffered, format="PNG")
                    img_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                    
                    image_dict[container_type] = img_base64
                    print(f"  Сопоставлено: {container_type} -> {image_file} ({len(img_base64)} символов)")
                    
                except Exception as e:
                    print(f"  Ошибка при обработке {image_file}: {e}")
                    continue
            
            return image_dict
            
        except Exception as e:
            print(f"Ошибка при извлечении из zip: {e}")
            return {}

# Дополнительная функция для анализа совпадений
def analyze_matching_possibilities(file_path, image_dict, data_sheet="data"):
    """
    Анализирует возможные совпадения между названиями из data и справочника
    """
    # Читаем данные из листа 'data'
    df = pd.read_excel(file_path, sheet_name=data_sheet)
    
    # Получаем уникальные типы контейнеров из data
    data_container_types = df['container_type'].dropna().unique()
    
    # Получаем типы из справочника
    ref_container_types = list(image_dict.keys())
    
    print("=== Анализ возможных совпадений ===")
    print(f"Типы контейнеров в data: {len(data_container_types)}")
    print(f"Типы контейнеров в справочнике: {len(ref_container_types)}")
    
    print("\nТипы контейнеров в data:")
    for i, container_type in enumerate(data_container_types, 1):
        print(f"  {i}. {container_type}")
    
    print("\nТипы контейнеров в справочнике:")
    for i, container_type in enumerate(ref_container_types, 1):
        print(f"  {i}. {container_type}")
    
    print("\n=== Возможные совпадения ===")
    
    for data_type in data_container_types:
        data_type_clean = str(data_type).strip().lower()
        found_matches = []
        
        # Точное совпадение
        for ref_type in ref_container_types:
            if data_type_clean == ref_type.lower().strip():
                found_matches.append(('точное', ref_type))
        
        # Вхождение data в ref
        for ref_type in ref_container_types:
            ref_type_clean = ref_type.lower().strip()
            if data_type_clean in ref_type_clean:
                found_matches.append(('data в ref', ref_type))
        
        # Вхождение ref в data
        for ref_type in ref_container_types:
            ref_type_clean = ref_type.lower().strip()
            if ref_type_clean in data_type_clean:
                found_matches.append(('ref в data', ref_type))
        
        if found_matches:
            print(f"\n'{data_type}':")
            for match_type, ref_type in found_matches:
                print(f"  -> {match_type}: '{ref_type}'")
        else:
            print(f"\n'{data_type}': НЕ НАЙДЕНО совпадений")
    
    return data_container_types, ref_container_types

def main():
    project_dir = Path().resolve() # Path(__file__).resolve()
    # project_dir = project_dir.parent.parent
    raw_data_path = project_dir / 'data' / 'raw'
    processed_data_path = project_dir / 'data' / 'processed'
    file_path = raw_data_path / 'ВПР_Полный_перечень_тестов_МДЖ_23_06_ОКОНЧАТЕЛЬНЫЙ.xlsx'
    
    try:
        print("=== Извлечение изображений из справочника пробирок ===")
        
        # Сначала пробуем основной метод
        image_dict = extract_images_from_reference_sheet(file_path)
        
        # Если не получилось, пробуем альтернативный метод
        if not image_dict:
            print("\n=== Пробуем альтернативный метод ===")
            image_dict = extract_images_alternative_approach(file_path)
        
        if not image_dict:
            print("Не удалось извлечь изображения обоими способами.")
            return
        
        print(f"\n=== Найдено изображений: {len(image_dict)} ===")
        for container_type, base64_str in image_dict.items():
            print(f"  {container_type}: {len(base64_str)} символов")
        
        # Анализируем возможные совпадения
        print(f"\n=== Анализ совпадений ===")
        analyze_matching_possibilities(file_path, image_dict)
        
        # Добавляем столбец с base64 в лист "data"
        print(f"\n=== Добавление столбца в лист 'data' ===")
        df = add_base64_to_data_sheet(file_path, image_dict)
        
        # Проверяем результат
        verify_base64_images(df)
        
        print("\n=== Операция завершена успешно! ===")
        
    except Exception as e:
        print(f"Произошла ошибка: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

# Дополнительная функция для отладки - просмотр структуры листа
def debug_sheet_structure(file_path, sheet_name="Справочник пробирок"):
    """
    Отображает структуру листа для отладки
    """
    workbook = openpyxl.load_workbook(file_path)
    worksheet = workbook[sheet_name]
    
    print(f"=== Структура листа '{sheet_name}' ===")
    print(f"Размер листа: {worksheet.max_row} строк x {worksheet.max_column} столбцов")
    print(f"Количество изображений: {len(worksheet._images)}")
    
    # Показываем первые 10 строк
    print("\nПервые 10 строк:")
    for row in range(1, min(11, worksheet.max_row + 1)):
        values = []
        for col in range(1, min(5, worksheet.max_column + 1)):
            cell_value = worksheet.cell(row=row, column=col).value
            values.append(str(cell_value)[:30] if cell_value else "")
        print(f"  Строка {row}: {' | '.join(values)}")
    
    # Информация об изображениях
    print(f"\nИнформация об изображениях:")
    for i, img in enumerate(worksheet._images):
        try:
            if hasattr(img.anchor, '_from'):
                row_idx = img.anchor._from.row + 1
                col_idx = img.anchor._from.col + 1
            else:
                row_idx = "неизвестно"
                col_idx = "неизвестно"
            print(f"  Изображение {i+1}: строка {row_idx}, столбец {col_idx}")
        except Exception as e:
            print(f"  Изображение {i+1}: ошибка определения позиции - {e}")
    
    workbook.close()

# Раскомментируйте для отладки:
# debug_sheet_structure(raw_data_path / 'ВПР_Полный_перечень_тестов_МДЖ_23_06_ОКОНЧАТЕЛЬНЫЙ.xlsx')


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\database\models.py ###

import aiosqlite
from datetime import datetime, timedelta

class Database:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    async def create_tables(self):
        async with aiosqlite.connect(self.db_path) as db:
            # Обновленная таблица пользователей
            await db.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id INTEGER PRIMARY KEY,
                    user_type TEXT CHECK(user_type IN ('client', 'employee')),
                    
                    -- Общие поля
                    name TEXT,
                    country TEXT DEFAULT 'BY',
                    registration_date TIMESTAMP,
                    role TEXT DEFAULT 'user',
                    is_active BOOLEAN DEFAULT TRUE,
                    
                    -- Поля для клиентов (ветеринарные клиники)
                    client_code TEXT,  -- Убрали UNIQUE, так как в одной клинике может быть много врачей
                    specialization TEXT,
                    
                    -- Поля для сотрудников
                    region TEXT,
                    department_function TEXT CHECK(department_function IN ('laboratory', 'sales', 'support', NULL))
                )
            ''')
        
            # Таблица для жалоб и предложений
            await db.execute('''
                CREATE TABLE IF NOT EXISTS feedback (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    feedback_type TEXT,
                    message TEXT,
                    timestamp TIMESTAMP,
                    status TEXT DEFAULT 'new',
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            # Упрощенная таблица для кодов активации (только для админов)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS activation_codes (
                    code TEXT PRIMARY KEY,
                    role TEXT DEFAULT 'admin',
                    is_used BOOLEAN DEFAULT FALSE,
                    used_by INTEGER,
                    used_at TIMESTAMP,
                    created_at TIMESTAMP
                )
            ''')
            
            # Таблица для статистики запросов
            await db.execute('''
                CREATE TABLE IF NOT EXISTS request_statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    request_type TEXT,
                    request_text TEXT,
                    timestamp TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            # Таблица для памяти разговоров
            await db.execute('''
                CREATE TABLE IF NOT EXISTS conversation_memory (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    type TEXT CHECK(type IN ('buffer','summary')),
                    content TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.commit()
    
    async def add_client(self, telegram_id: int, name: str, client_code: str, 
                        specialization: str, country: str = 'BY'):
        """Добавление клиента (ветеринарной клиники)"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO users (telegram_id, user_type, name, client_code, 
                                     specialization, country, registration_date, role)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (telegram_id, 'client', name, client_code, specialization, 
                     country, datetime.now(), 'user'))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def add_employee(self, telegram_id: int, name: str, region: str, 
                          department_function: str, country: str = 'BY'):
        """Добавление сотрудника"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO users (telegram_id, user_type, name, region, 
                                     department_function, country, registration_date, role)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (telegram_id, 'employee', name, region, department_function, 
                     country, datetime.now(), 'user'))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def get_user(self, telegram_id: int):
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                'SELECT * FROM users WHERE telegram_id = ?', 
                (telegram_id,)
            )
            return await cursor.fetchone()
    
    async def get_user_role(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user['role'] if user else None
    
    async def update_user_role(self, telegram_id: int, role: str):
        """Обновление роли пользователя (только для админа)"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute(
                'UPDATE users SET role = ? WHERE telegram_id = ?',
                (role, telegram_id)
            )
            await db.commit()
    
    async def check_activation_code(self, code: str):
        """Проверка кода активации администратора"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute('''
                SELECT * FROM activation_codes 
                WHERE code = ? AND is_used = FALSE
            ''', (code.upper(),))
            return await cursor.fetchone()
    
    async def use_activation_code(self, code: str, user_id: int):
        """Использование кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                UPDATE activation_codes 
                SET is_used = TRUE, used_by = ?, used_at = ?
                WHERE code = ?
            ''', (user_id, datetime.now(), code.upper()))
            await db.commit()
    
    async def create_admin_code(self, code: str):
        """Создание одноразового кода активации администратора"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO activation_codes (code, role, created_at)
                    VALUES (?, 'admin', ?)
                ''', (code.upper(), datetime.now()))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def user_exists(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user is not None
    
    async def add_request_stat(self, user_id: int, request_type: str, request_text: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO request_statistics (user_id, request_type, 
                                              request_text, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, request_type, request_text, datetime.now()))
            await db.commit()
    
    async def add_feedback(self, user_id: int, feedback_type: str, message: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO feedback (user_id, feedback_type, message, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, feedback_type, message, datetime.now()))
            await db.commit()

    async def get_statistics(self):
        """Получение статистики для администратора"""
        async with aiosqlite.connect(self.db_path) as db:
            # Статистика пользователей
            cursor = await db.execute("SELECT user_type, COUNT(*) FROM users GROUP BY user_type")
            type_stats = await cursor.fetchall()

            stats = {'total_users': 0, 'clients': 0, 'employees': 0, 'admins': 0}
            for user_type, count in type_stats:
                stats['total_users'] += count
                if user_type == 'client':
                    stats['clients'] = count
                elif user_type == 'employee':
                    stats['employees'] = count

            # Считаем админов отдельно
            cursor = await db.execute("SELECT COUNT(*) FROM users WHERE role = 'admin'")
            admin_count = await cursor.fetchone()
            stats['admins'] = admin_count[0] if admin_count else 0

            # Статистика запросов
            cursor = await db.execute("SELECT request_type, COUNT(*) FROM request_statistics GROUP BY request_type")
            request_stats = await cursor.fetchall()

            stats['total_requests'] = 0
            stats['questions'] = 0
            stats['callbacks'] = 0
            for req_type, count in request_stats:
                stats['total_requests'] += count
                if req_type == 'question':
                    stats['questions'] = count
                elif req_type == 'callback_request':
                    stats['callbacks'] = count

            # Статистика обратной связи
            cursor = await db.execute("SELECT feedback_type, COUNT(*) FROM feedback GROUP BY feedback_type")
            feedback_stats = await cursor.fetchall()

            stats['suggestions'] = 0
            stats['complaints'] = 0
            for fb_type, count in feedback_stats:
                if fb_type == 'suggestion':
                    stats['suggestions'] = count
                elif fb_type == 'complaint':
                    stats['complaints'] = count

            return stats
        
    async def add_memory(self, user_id: int, type: str, content: str):
        """Сохранение памяти разговора"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO conversation_memory (user_id, type, content)
                VALUES (?, ?, ?)
            ''', (user_id, type, content))
            await db.commit()

    async def get_buffer(self, user_id: int) -> list[str]:
        """Получение буфера сообщений"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute('''
                SELECT content FROM conversation_memory
                WHERE user_id = ? AND type = 'buffer'
                ORDER BY timestamp
            ''', (user_id,))
            rows = await cursor.fetchall()
            return [r[0] for r in rows]

    async def clear_buffer(self, user_id: int):
        """Очистка буфера сообщений"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                DELETE FROM conversation_memory
                WHERE user_id = ? AND type = 'buffer'
            ''', (user_id,))
            await db.commit()

    async def get_latest_summary(self, user_id: int) -> str | None:
        """Получение последней сводки разговора"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute('''
                SELECT content FROM conversation_memory
                WHERE user_id = ? AND type = 'summary'
                ORDER BY timestamp DESC
                LIMIT 1
            ''', (user_id,))
            row = await cursor.fetchone()
            return row[0] if row else None

    # Новые методы для администраторов
    async def get_broadcast_recipients(self, broadcast_type: str) -> list:
        """Получить список ID получателей для рассылки"""
        async with aiosqlite.connect(self.db_path) as db:
            if broadcast_type == 'all':
                query = "SELECT telegram_id FROM users WHERE is_active = TRUE"
            elif broadcast_type == 'clients':
                query = "SELECT telegram_id FROM users WHERE user_type = 'client' AND is_active = TRUE"
            elif broadcast_type == 'employees':
                query = "SELECT telegram_id FROM users WHERE user_type = 'employee' AND is_active = TRUE"
            else:
                return []
            
            cursor = await db.execute(query)
            rows = await cursor.fetchall()
            return [row[0] for row in rows]

    async def get_recent_users(self, limit: int = 10) -> list:
        """Получить последних зарегистрированных пользователей"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute('''
                SELECT * FROM users 
                ORDER BY registration_date DESC 
                LIMIT ?
            ''', (limit,))
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

    async def get_recent_feedback(self, limit: int = 5) -> list:
        """Получить последние обращения"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute('''
                SELECT f.*, u.name as user_name 
                FROM feedback f
                LEFT JOIN users u ON f.user_id = u.telegram_id
                ORDER BY f.timestamp DESC 
                LIMIT ?
            ''', (limit,))
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

    async def clear_old_logs(self, days: int = 30) -> int:
        """Очистить старые записи логов"""
        async with aiosqlite.connect(self.db_path) as db:
            cutoff_date = datetime.now() - timedelta(days=days)
            
            cursor = await db.execute('''
                DELETE FROM conversation_memory 
                WHERE timestamp < ?
            ''', (cutoff_date,))
            
            deleted_count = cursor.rowcount
            
            cursor = await db.execute('''
                DELETE FROM request_statistics 
                WHERE timestamp < ?
            ''', (cutoff_date,))
            
            deleted_count += cursor.rowcount
            
            await db.commit()
            return deleted_count

    async def get_uptime(self) -> str:
        """Получить время работы системы"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute('''
                SELECT MIN(registration_date) FROM users
            ''')
            first_registration = await cursor.fetchone()
            
            if first_registration and first_registration[0]:
                first_date = datetime.fromisoformat(first_registration[0])
                uptime = datetime.now() - first_date
                
                days = uptime.days
                hours = uptime.seconds // 3600
                minutes = (uptime.seconds % 3600) // 60
                
                return f"{days} дней, {hours} часов, {minutes} минут"
            
            return "Нет данных"


### FILE: C:\Users\Legion\AI_VET_Assistant-2\src\database\__init__.py ###



### FILE: C:\Users\Legion\AI_VET_Assistant-2\tools\email_sender.py ###

import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import logging
from config import EMAIL_HOST, EMAIL_PORT, EMAIL_LOGIN, EMAIL_PASSWORD, EMAIL_TO

logger = logging.getLogger(__name__)

async def send_callback_email(user_data: dict, phone: str, message: str):
    """Отправка email о заказе обратного звонка"""
    try:
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f'Заказ обратного звонка - {user_data.get("username", "Неизвестный пользователь")}'
        msg['From'] = EMAIL_LOGIN
        msg['To'] = EMAIL_TO
        
        html = f"""
        <html>
          <body style="font-family: Arial, sans-serif;">
            <h2>Новый заказ обратного звонка</h2>
            <p><strong>Дата и время:</strong> {datetime.now().strftime('%d.%m.%Y %H:%M')}</p>
            
            <h3>Информация о клиенте:</h3>
            <ul>
              <li><strong>Имя:</strong> {user_data.get('username', 'Не указано')}</li>
              <li><strong>Код клиента:</strong> {user_data.get('client_code', 'Не указан')}</li>
              <li><strong>Питомец:</strong> {user_data.get('pet_name', 'Не указан')} ({user_data.get('pet_type', 'Не указан')})</li>
              <li><strong>Telegram ID:</strong> {user_data.get('telegram_id', 'Не указан')}</li>
            </ul>
            
            <h3>Контактные данные:</h3>
            <ul>
              <li><strong>Телефон:</strong> {phone}</li>
            </ul>
            
            <h3>Сообщение:</h3>
            <p style="background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
              {message}
            </p>
            
            <hr>
            <p style="color: #666; font-size: 12px;">
              Это автоматическое сообщение от бота ветеринарной клиники
            </p>
          </body>
        </html>
        """
        
        # Текстовая версия
        text = f"""
        Новый заказ обратного звонка
        
        Дата и время: {datetime.now().strftime('%d.%m.%Y %H:%M')}
        
        Информация о клиенте:
        - Имя: {user_data.get('username', 'Не указано')}
        - Код клиента: {user_data.get('client_code', 'Не указан')}
        - Питомец: {user_data.get('pet_name', 'Не указан')} ({user_data.get('pet_type', 'Не указан')})
        - Telegram ID: {user_data.get('telegram_id', 'Не указан')}
        
        Контактные данные:
        - Телефон: {phone}
        
        Сообщение:
        {message}
        
        ---
        Это автоматическое сообщение от бота ветеринарной клиники
        """
        
        part1 = MIMEText(text, 'plain')
        part2 = MIMEText(html, 'html')
        
        msg.attach(part1)
        msg.attach(part2)
        
        # Отправляем email
        if EMAIL_LOGIN and EMAIL_PASSWORD:
            await aiosmtplib.send(
                msg,
                hostname=EMAIL_HOST,
                port=EMAIL_PORT,
                start_tls=True,
                username=EMAIL_LOGIN,
                password=EMAIL_PASSWORD,
            )
            logger.info(f"Email успешно отправлен на {EMAIL_TO}")
            return True
        else:
            logger.error("Email credentials not configured")
            return False
            
    except Exception as e:
        logger.error(f"Ошибка при отправке email: {e}")
        return False


### FILE: C:\Users\Legion\AI_VET_Assistant-2\utils\email_sender.py ###

import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import logging
from config import EMAIL_HOST, EMAIL_PORT, EMAIL_LOGIN, EMAIL_PASSWORD, EMAIL_TO

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def send_feedback_email(user_data: dict, feedback_type: str, message: str):
    """Отправка email о предложениях и жалобах"""
    try:
        type_text = "Предложение" if feedback_type == "suggestion" else "Жалоба"
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f'{type_text} - {user_data.get("name", "Неизвестный пользователь")}'
        msg['From'] = EMAIL_LOGIN
        msg['To'] = EMAIL_TO
        
        # Определяем тип пользователя
        if user_data.get('user_type') == 'client':
            user_type = "Ветеринарный врач клиники-партнера"
            additional_info = f"""
              <li><strong>Код клиента:</strong> {user_data.get('client_code', 'Не указан')}</li>
              <li><strong>Специализация:</strong> {user_data.get('specialization', 'Не указана')}</li>
            """
        elif user_data.get('user_type') == 'employee':
            user_type = "Сотрудник VET UNION"
            dept_map = {'laboratory': 'Лаборатория', 'sales': 'Продажи', 'support': 'Поддержка'}
            dept = dept_map.get(user_data.get('department_function', ''), user_data.get('department_function', ''))
            additional_info = f"""
              <li><strong>Регион:</strong> {user_data.get('region', 'Не указан')}</li>
              <li><strong>Функция:</strong> {dept}</li>
            """
        else:
            user_type = "Пользователь"
            additional_info = ""
        
        html = f"""
        <html>
          <body style="font-family: Arial, sans-serif;">
            <h2>{type_text}</h2>
            <p><strong>Дата и время:</strong> {datetime.now().strftime('%d.%m.%Y %H:%M')}</p>
            
            <h3>Информация о пользователе:</h3>
            <ul>
              <li><strong>Имя:</strong> {user_data.get('name', 'Не указано')}</li>
              <li><strong>Тип:</strong> {user_type}</li>
              {additional_info}
              <li><strong>Telegram ID:</strong> {user_data.get('telegram_id', 'Не указан')}</li>
            </ul>
            
            <h3>Текст обращения:</h3>
            <p style="background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
              {message}
            </p>
          </body>
        </html>
        """
        
        text = f"""
        {type_text}
        
        Дата и время: {datetime.now().strftime('%d.%m.%Y %H:%M')}
        
        Информация о пользователе:
        - Имя: {user_data.get('name', 'Не указано')}
        - Тип: {user_type}
        - Telegram ID: {user_data.get('telegram_id', 'Не указан')}
        
        Текст обращения:
        {message}
        """
        
        part1 = MIMEText(text, 'plain', 'utf-8')
        part2 = MIMEText(html, 'html', 'utf-8')
        
        msg.attach(part1)
        msg.attach(part2)
        
        if EMAIL_LOGIN and EMAIL_PASSWORD:
            logger.info(f"Attempting to send email from {EMAIL_LOGIN} to {EMAIL_TO}")
            
            response = await aiosmtplib.send(
                msg,
                hostname=EMAIL_HOST,
                port=EMAIL_PORT,
                start_tls=True,
                username=EMAIL_LOGIN,
                password=EMAIL_PASSWORD,
            )
            
            logger.info(f"Email sent successfully. Response: {response}")
            return True
        else:
            logger.error("Email credentials not configured")
            return False
            
    except Exception as e:
        logger.error(f"Ошибка при отправке email: {e}", exc_info=True)
        return False

async def send_callback_email(user_data: dict, phone: str, message: str):
    """Отправка email о заказе обратного звонка"""
    try:
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f'Заказ обратного звонка - {user_data.get("name", "Неизвестный пользователь")}'
        msg['From'] = EMAIL_LOGIN
        msg['To'] = EMAIL_TO
        msg['Reply-To'] = EMAIL_LOGIN
        msg['X-Mailer'] = 'Python/aiosmtplib'
        
        # Определяем тип пользователя и дополнительную информацию
        if user_data.get('user_type') == 'client':
            user_type = "Ветеринарный врач клиники-партнера"
            additional_info = f"""
              <li><strong>Код клиента:</strong> {user_data.get('client_code', 'Не указан')}</li>
              <li><strong>Специализация:</strong> {user_data.get('specialization', 'Не указана')}</li>
            """
            additional_text = f"""
        - Код клиента: {user_data.get('client_code', 'Не указан')}
        - Специализация: {user_data.get('specialization', 'Не указана')}"""
        elif user_data.get('user_type') == 'employee':
            user_type = "Сотрудник VET UNION"
            dept_map = {'laboratory': 'Лаборатория', 'sales': 'Продажи', 'support': 'Поддержка'}
            dept = dept_map.get(user_data.get('department_function', ''), user_data.get('department_function', ''))
            additional_info = f"""
              <li><strong>Регион:</strong> {user_data.get('region', 'Не указан')}</li>
              <li><strong>Функция:</strong> {dept}</li>
            """
            additional_text = f"""
        - Регион: {user_data.get('region', 'Не указан')}
        - Функция: {dept}"""
        else:
            user_type = "Пользователь"
            additional_info = ""
            additional_text = ""
        
        html = f"""
        <html>
          <head>
            <meta charset="utf-8">
          </head>
          <body style="font-family: Arial, sans-serif;">
            <h2>Новый заказ обратного звонка</h2>
            <p><strong>Дата и время:</strong> {datetime.now().strftime('%d.%m.%Y %H:%M')}</p>
            
            <h3>Информация о пользователе:</h3>
            <ul>
              <li><strong>Имя:</strong> {user_data.get('name', 'Не указано')}</li>
              <li><strong>Тип:</strong> {user_type}</li>
              {additional_info}
              <li><strong>Telegram ID:</strong> {user_data.get('telegram_id', 'Не указан')}</li>
            </ul>
            
            <h3>Контактные данные:</h3>
            <ul>
              <li><strong>Телефон:</strong> {phone}</li>
            </ul>
            
            <h3>Сообщение:</h3>
            <p style="background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
              {message}
            </p>
            
            <hr>
            <p style="color: #666; font-size: 12px;">
              Это автоматическое сообщение от бота лаборатории VET UNION
            </p>
          </body>
        </html>
        """
        
        text = f"""
        Новый заказ обратного звонка
        
        Дата и время: {datetime.now().strftime('%d.%m.%Y %H:%M')}
        
        Информация о пользователе:
        - Имя: {user_data.get('name', 'Не указано')}
        - Тип: {user_type}{additional_text}
        - Telegram ID: {user_data.get('telegram_id', 'Не указан')}
        
        Контактные данные:
        - Телефон: {phone}
        
        Сообщение:
        {message}
        
        ---
        Это автоматическое сообщение от бота лаборатории VET UNION
        """
        
        part1 = MIMEText(text, 'plain', 'utf-8')
        part2 = MIMEText(html, 'html', 'utf-8')
        
        msg.attach(part1)
        msg.attach(part2)
        
        if EMAIL_LOGIN and EMAIL_PASSWORD:
            logger.info(f"Attempting to send callback email from {EMAIL_LOGIN} to {EMAIL_TO}")
            
            response = await aiosmtplib.send(
                msg,
                hostname=EMAIL_HOST,
                port=EMAIL_PORT,
                start_tls=True,
                username=EMAIL_LOGIN,
                password=EMAIL_PASSWORD,
            )
            
            logger.info(f"Email sent successfully. SMTP Response: {response}")
            return True
        else:
            logger.error("Email credentials not configured")
            return False
            
    except aiosmtplib.SMTPException as e:
        logger.error(f"SMTP error: {e}", exc_info=True)
        return False
    except Exception as e:
        logger.error(f"Ошибка при отправке email: {e}", exc_info=True)
        return False


### FILE: C:\Users\Legion\AI_VET_Assistant-2\utils\excel_exporter.py ###

import pandas as pd
from datetime import datetime
from pathlib import Path
import aiosqlite
from typing import Optional
import io

class ExcelExporter:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    async def export_all_data(self) -> bytes:
        """Экспорт всех данных в Excel"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.BytesIO()
            
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                # Экспорт пользователей
                users_df = await self._get_users_dataframe(db)
                users_df.to_excel(writer, sheet_name='Пользователи', index=False)
                
                # Экспорт вопросов
                questions_df = await self._get_questions_dataframe(db)
                questions_df.to_excel(writer, sheet_name='Вопросы', index=False)
                
                # Экспорт запросов на звонок
                callbacks_df = await self._get_callbacks_dataframe(db)
                callbacks_df.to_excel(writer, sheet_name='Звонки', index=False)
                
                # Экспорт обратной связи
                feedback_df = await self._get_feedback_dataframe(db)
                feedback_df.to_excel(writer, sheet_name='Обратная связь', index=False)
                
                # Форматирование
                workbook = writer.book
                for worksheet in workbook.worksheets():
                    worksheet.set_column('A:Z', 20)
            
            output.seek(0)
            return output.read()
    
    async def export_users(self) -> bytes:
        """Экспорт только пользователей"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.BytesIO()
            users_df = await self._get_users_dataframe(db)
            
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                users_df.to_excel(writer, sheet_name='Пользователи', index=False)
                
                # Добавляем статистику
                stats_df = self._calculate_user_stats(users_df)
                stats_df.to_excel(writer, sheet_name='Статистика', index=False)
                
                # Форматирование
                workbook = writer.book
                for worksheet in workbook.worksheets():
                    worksheet.set_column('A:Z', 20)
            
            output.seek(0)
            return output.read()
    
    async def export_questions(self) -> bytes:
        """Экспорт только вопросов"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.BytesIO()
            questions_df = await self._get_questions_dataframe(db)
            
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                questions_df.to_excel(writer, sheet_name='Вопросы', index=False)
                
                # Форматирование
                workbook = writer.book
                worksheet = writer.sheets['Вопросы']
                worksheet.set_column('A:A', 15)  # ID
                worksheet.set_column('B:B', 20)  # Пользователь
                worksheet.set_column('C:C', 50)  # Вопрос
                worksheet.set_column('D:D', 20)  # Дата
            
            output.seek(0)
            return output.read()
    
    async def export_callbacks(self) -> bytes:
        """Экспорт только запросов на звонок"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.BytesIO()
            callbacks_df = await self._get_callbacks_dataframe(db)
            
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                callbacks_df.to_excel(writer, sheet_name='Звонки', index=False)
                
                # Форматирование
                workbook = writer.book
                worksheet = writer.sheets['Звонки']
                worksheet.set_column('A:Z', 20)
            
            output.seek(0)
            return output.read()
    
    async def export_feedback(self) -> bytes:
        """Экспорт только обратной связи"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.BytesIO()
            feedback_df = await self._get_feedback_dataframe(db)
            
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                feedback_df.to_excel(writer, sheet_name='Обратная связь', index=False)
                
                # Форматирование
                workbook = writer.book
                worksheet = writer.sheets['Обратная связь']
                worksheet.set_column('A:Z', 20)
            
            output.seek(0)
            return output.read()
    
    async def _get_users_dataframe(self, db) -> pd.DataFrame:
        """Получить DataFrame с пользователями для новой структуры БД"""
        cursor = await db.execute('''
            SELECT 
                telegram_id as "Telegram ID",
                name as "Имя",
                CASE user_type
                    WHEN 'client' THEN 'Клиент (ветеринар)'
                    WHEN 'employee' THEN 'Сотрудник'
                    ELSE 'Пользователь'
                END as "Тип пользователя",
                client_code as "Код клиента",
                specialization as "Специализация",
                region as "Регион",
                CASE department_function
                    WHEN 'laboratory' THEN 'Лаборатория'
                    WHEN 'sales' THEN 'Продажи'
                    WHEN 'support' THEN 'Поддержка'
                    ELSE department_function
                END as "Функция",
                CASE country
                    WHEN 'BY' THEN 'Беларусь'
                    WHEN 'RU' THEN 'Россия'
                    WHEN 'KZ' THEN 'Казахстан'
                    WHEN 'AM' THEN 'Армения'
                    ELSE country
                END as "Страна",
                CASE role
                    WHEN 'admin' THEN 'Администратор'
                    WHEN 'user' THEN 'Пользователь'
                    ELSE role
                END as "Роль",
                registration_date as "Дата регистрации",
                CASE is_active
                    WHEN 1 THEN 'Активен'
                    ELSE 'Неактивен'
                END as "Статус"
            FROM users
            ORDER BY registration_date DESC
        ''')
        
        rows = await cursor.fetchall()
        return pd.DataFrame(rows, columns=[desc[0] for desc in cursor.description])
    
    async def _get_questions_dataframe(self, db) -> pd.DataFrame:
        """Получить DataFrame с вопросами"""
        cursor = await db.execute('''
            SELECT 
                rs.id as "ID",
                u.name as "Пользователь",
                u.user_type as user_type_raw,
                u.client_code as "Код клиента",
                rs.request_text as "Вопрос",
                rs.timestamp as "Дата и время"
            FROM request_statistics rs
            LEFT JOIN users u ON rs.user_id = u.telegram_id
            WHERE rs.request_type = 'question'
            ORDER BY rs.timestamp DESC
        ''')
        
        rows = await cursor.fetchall()
        df = pd.DataFrame(rows, columns=[desc[0] for desc in cursor.description])
        
        # Добавляем колонку типа пользователя
        if not df.empty:
            df['Тип пользователя'] = df['user_type_raw'].apply(
                lambda x: 'Клиент' if x == 'client' else ('Сотрудник' if x == 'employee' else 'Пользователь')
            )
            df = df.drop('user_type_raw', axis=1)
        
        return df
    
    async def _get_callbacks_dataframe(self, db) -> pd.DataFrame:
        """Получить DataFrame с запросами на звонок"""
        cursor = await db.execute('''
            SELECT 
                rs.id as "ID",
                u.name as "Пользователь",
                u.user_type as user_type_raw,
                u.client_code as "Код клиента",
                u.specialization as "Специализация",
                rs.request_text as "Детали запроса",
                rs.timestamp as "Дата и время"
            FROM request_statistics rs
            LEFT JOIN users u ON rs.user_id = u.telegram_id
            WHERE rs.request_type = 'callback_request'
            ORDER BY rs.timestamp DESC
        ''')
        
        rows = await cursor.fetchall()
        df = pd.DataFrame(rows, columns=[desc[0] for desc in cursor.description])
        
        # Извлекаем телефон из текста запроса и добавляем тип пользователя
        if not df.empty:
            df['Телефон'] = df['Детали запроса'].str.extract(r'Телефон: ([^,]+)')
            df['Сообщение'] = df['Детали запроса'].str.extract(r'Сообщение: (.+)')
            df['Тип пользователя'] = df['user_type_raw'].apply(
                lambda x: 'Клиент' if x == 'client' else ('Сотрудник' if x == 'employee' else 'Пользователь')
            )
            df = df.drop(['Детали запроса', 'user_type_raw'], axis=1)
        
        return df
    
    async def _get_feedback_dataframe(self, db) -> pd.DataFrame:
        """Получить DataFrame с обратной связью"""
        cursor = await db.execute('''
            SELECT 
                f.id as "ID",
                u.name as "Пользователь",
                u.user_type as user_type_raw,
                u.client_code as "Код клиента",
                CASE f.feedback_type
                    WHEN 'suggestion' THEN 'Предложение'
                    WHEN 'complaint' THEN 'Жалоба'
                END as "Тип обращения",
                f.message as "Сообщение",
                f.timestamp as "Дата и время",
                CASE f.status
                    WHEN 'new' THEN 'Новое'
                    WHEN 'in_progress' THEN 'В работе'
                    WHEN 'resolved' THEN 'Решено'
                    ELSE f.status
                END as "Статус"
            FROM feedback f
            LEFT JOIN users u ON f.user_id = u.telegram_id
            ORDER BY f.timestamp DESC
        ''')
        
        rows = await cursor.fetchall()
        df = pd.DataFrame(rows, columns=[desc[0] for desc in cursor.description])
        
        # Добавляем тип пользователя
        if not df.empty:
            df['Тип пользователя'] = df['user_type_raw'].apply(
                lambda x: 'Клиент' if x == 'client' else ('Сотрудник' if x == 'employee' else 'Пользователь')
            )
            df = df.drop('user_type_raw', axis=1)
        
        return df
    
    def _calculate_user_stats(self, users_df: pd.DataFrame) -> pd.DataFrame:
        """Рассчитать статистику по пользователям"""
        stats = []
        
        # Общая статистика
        stats.append({
            'Показатель': 'Всего пользователей',
            'Значение': len(users_df)
        })
        
        # По типам пользователей
        if 'Тип пользователя' in users_df.columns:
            type_counts = users_df['Тип пользователя'].value_counts()
            for user_type, count in type_counts.items():
                stats.append({
                    'Показатель': f'{user_type}',
                    'Значение': count
                })
        
        # По ролям
        if 'Роль' in users_df.columns:
            role_counts = users_df['Роль'].value_counts()
            for role, count in role_counts.items():
                stats.append({
                    'Показатель': f'Роль: {role}',
                    'Значение': count
                })
        
        # По странам
        if 'Страна' in users_df.columns:
            country_counts = users_df['Страна'].value_counts()
            for country, count in country_counts.items():
                stats.append({
                    'Показатель': f'Из {country}',
                    'Значение': count
                })
        
        # По специализациям (для клиентов)
        if 'Специализация' in users_df.columns:
            spec_df = users_df[users_df['Специализация'].notna()]
            if not spec_df.empty:
                spec_counts = spec_df['Специализация'].value_counts()
                stats.append({
                    'Показатель': '--- Специализации ---',
                    'Значение': ''
                })
                for spec, count in spec_counts.items():
                    stats.append({
                        'Показатель': spec,
                        'Значение': count
                    })
        
        # По функциям (для сотрудников)
        if 'Функция' in users_df.columns:
            func_df = users_df[users_df['Функция'].notna()]
            if not func_df.empty:
                func_counts = func_df['Функция'].value_counts()
                stats.append({
                    'Показатель': '--- Функции сотрудников ---',
                    'Значение': ''
                })
                for func, count in func_counts.items():
                    stats.append({
                        'Показатель': func,
                        'Значение': count
                    })
        
        # Активные/неактивные
        if 'Статус' in users_df.columns:
            status_counts = users_df['Статус'].value_counts()
            for status, count in status_counts.items():
                stats.append({
                    'Показатель': f'Статус: {status}',
                    'Значение': count
                })
        
        return pd.DataFrame(stats)


### FILE: C:\Users\Legion\AI_VET_Assistant-2\utils\json_extractor.py ###

import json
import re
from typing import Any, Optional, Union

def extract_json(content: str) -> Union[dict[str, Any], str]:
    """
    Attempts to extract and parse a JSON object from a given string.

    The function handles the following cases:
    1. Direct JSON content wrapped in ```json ... ``` blocks.
    2. Automatically replaces Python-style 'None' with JSON-valid 'null'.
    3. Fallback to extracting the last JSON-looking substring.
    4. Partial JSON blocks within the content.

    Args:
        content (str): The raw input string potentially containing JSON.

    Returns:
        Union[dict[str, Any], str]: A parsed JSON object if successful, otherwise the original string.
    """
    def try_parse(json_str: str) -> Optional[dict[str, Any]]:
        try:
            return json.loads(json_str)
        except json.JSONDecodeError:
            return None

    content_cleaned = re.sub(r'^```(?:json)?\s*|\s*```$', '', content.strip(), flags=re.DOTALL) # Strip code block markers like ```json ... ```
    content_cleaned = re.sub(r'\bNone\b', 'null', content_cleaned) # Replace Python-style None or 'None' with JSON null
    content_cleaned = re.sub(r'"\s*None\s*"', 'null', content_cleaned)

    # Attempt 1: Parse full cleaned content
    result = try_parse(content_cleaned)
    if result is not None:
        return result

    # Attempt 2: Try substring from last '{' to last '}'
    last_open = content_cleaned.rfind('{')
    last_close = content_cleaned.rfind('}')
    if last_open != -1 and last_close > last_open:
        result = try_parse(content_cleaned[last_open:last_close + 1])
        if result is not None:
            return result

    # Attempt 3: Try all shallow JSON-like blocks
    json_blocks = re.findall(r'(?s)\{.*?\}', content_cleaned)
    if json_blocks:
        for block in reversed(json_blocks):
            result = try_parse(block)
            if result is not None:
                return result

    # Parsing failed in all strategies — return original content (or None, then def extract_json(content: str) -> Optional[dict[str, Any]])
    return None


### FILE: C:\Users\Legion\AI_VET_Assistant-2\utils\test_environment.py ###

import sys

REQUIRED_PYTHON = "python3"
REQUIRED_MAJOR = 3


def main():
    if sys.version_info.major != REQUIRED_MAJOR:
        raise TypeError(f"This project requires Python {REQUIRED_MAJOR}. Found: Python {sys.version}")
    else:
        print(">>> Development environment passes all tests!")


if __name__ == '__main__':
    main()


### FILE: C:\Users\Legion\AI_VET_Assistant-2\utils\__init__.py ###

