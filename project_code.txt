---- check_api.py ----
import os
from dotenv import load_dotenv
import requests

load_dotenv()

api_key = os.getenv('OPENROUTER_API_KEY')
print(f"API Key: {api_key[:15]}...")

response = requests.get(
    'https://openrouter.ai/api/v1/auth/key',
    headers={'Authorization': f'Bearer {api_key}'}
)
print("Status:", response.status_code)
print("Response:", response.json())

---- config.py ----
import os
from dotenv import load_dotenv

load_dotenv()

# API
BOT_API_KEY = os.getenv('BOT_API_KEY')
OPENROUTER_API_KEY = os.getenv('OPENROUTER_API_KEY')
DEEPINFRA_API_KEY = os.getenv('DEEPINFRA_API_KEY')

# Gmail SMTP config
EMAIL_HOST = os.getenv('EMAIL_HOST', 'smtp.gmail.com')
EMAIL_PORT = int(os.getenv('EMAIL_PORT', 587))
EMAIL_LOGIN = os.getenv('EMAIL_LOGIN')
EMAIL_PASSWORD = os.getenv('EMAIL_PASSWORD')
EMAIL_TO = os.getenv('EMAIL_TO')


---- main.py ----
import asyncio
from bot.handlers import bot, dp
from src.database.db_init import db

async def main():
    await db.create_tables()
    print("[INFO] Starting bot polling…")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print('Shut down')

---- models.py ----
import aiosqlite
from datetime import datetime

class Database:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    async def create_tables(self):
        async with aiosqlite.connect(self.db_path) as db:
            # Таблица пользователей
            await db.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id INTEGER PRIMARY KEY,
                    username TEXT,
                    client_code TEXT UNIQUE,
                    pet_name TEXT,
                    pet_type TEXT,
                    country TEXT DEFAULT 'RU',
                    registration_date TIMESTAMP,
                    role TEXT DEFAULT 'client',
                    is_active BOOLEAN DEFAULT TRUE
                )
            ''')
            
            # Таблица для жалоб и предложений
            await db.execute('''
                CREATE TABLE IF NOT EXISTS feedback (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    feedback_type TEXT,
                    message TEXT,
                    timestamp TIMESTAMP,
                    status TEXT DEFAULT 'new',
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            # Упрощенная таблица для кодов активации (без срока действия)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS activation_codes (
                    code TEXT PRIMARY KEY,
                    role TEXT,
                    is_used BOOLEAN DEFAULT FALSE,
                    used_by INTEGER,
                    used_at TIMESTAMP,
                    created_at TIMESTAMP
                )
            ''')
            
            # Таблица для статистики запросов
            await db.execute('''
                CREATE TABLE IF NOT EXISTS request_statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    request_type TEXT,
                    request_text TEXT,
                    timestamp TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            await db.commit()
            await self._migrate_database(db)
    
    async def _migrate_database(self, db):
        """Проверка и обновление структуры БД"""
        cursor = await db.execute("PRAGMA table_info(users)")
        columns = await cursor.fetchall()
        column_names = [col[1] for col in columns]
        
        # Миграция старых ролей на новые
        if 'role' in column_names:
            await db.execute("UPDATE users SET role = 'client' WHERE role = 'user'")
            await db.execute("UPDATE users SET role = 'staff' WHERE role IN ('moderator', 'vip')")
        
        if 'country' not in column_names:
            await db.execute("ALTER TABLE users ADD COLUMN country TEXT DEFAULT 'RU'")
            
        await db.commit()
    
    async def add_user(self, telegram_id: int, username: str, 
                      client_code: str, pet_name: str, pet_type: str, country: str = 'RU'):
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO users (telegram_id, username, client_code, 
                                     pet_name, pet_type, country, registration_date, role)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (telegram_id, username, client_code, pet_name, 
                     pet_type, country, datetime.now(), 'client'))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
            except Exception as e:
                print(f"Error adding user: {e}")
                return False
    
    async def get_user(self, telegram_id: int):
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                'SELECT * FROM users WHERE telegram_id = ?', 
                (telegram_id,)
            )
            return await cursor.fetchone()
    
    async def get_user_role(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user['role'] if user else None
    
    async def update_user_role(self, telegram_id: int, role: str):
        """Обновление роли пользователя (навсегда)"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute(
                'UPDATE users SET role = ? WHERE telegram_id = ?',
                (role, telegram_id)
            )
            await db.commit()
    
    async def check_activation_code(self, code: str):
        """Проверка кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute('''
                SELECT * FROM activation_codes 
                WHERE code = ? AND is_used = FALSE
            ''', (code.upper(),))
            return await cursor.fetchone()
    
    async def use_activation_code(self, code: str, user_id: int):
        """Использование кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                UPDATE activation_codes 
                SET is_used = TRUE, used_by = ?, used_at = ?
                WHERE code = ?
            ''', (user_id, datetime.now(), code.upper()))
            await db.commit()
    
    async def create_activation_code(self, code: str, role: str):
        """Создание одноразового кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO activation_codes (code, role, created_at)
                    VALUES (?, ?, ?)
                ''', (code.upper(), role, datetime.now()))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def user_exists(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user is not None
    
    async def check_client_code_exists(self, client_code: str):
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute(
                'SELECT telegram_id FROM users WHERE client_code = ?', 
                (client_code,)
            )
            result = await cursor.fetchone()
            return result is not None
    
    async def add_request_stat(self, user_id: int, request_type: str, 
                              request_text: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO request_statistics (user_id, request_type, 
                                              request_text, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, request_type, request_text, datetime.now()))
            await db.commit()
    
    async def add_feedback(self, user_id: int, feedback_type: str, message: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO feedback (user_id, feedback_type, message, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, feedback_type, message, datetime.now()))
            await db.commit()

---- parser.py ----
from telegram import Update
from telegram.ext import Application, MessageHandler, filters

async def get_file_id(update: Update, context):
    if update.message.photo:
        file_id = update.message.photo[-1].file_id
        await update.message.reply_text(f"Photo file_id: {file_id}")
    elif update.message.document:
        file_id = update.message.document.file_id
        await update.message.reply_text(f"Document file_id: {file_id}")

app = Application.builder().token("8136766001:AAGKhc5s3yWEvYsNP9MFuC2LSZntFQSlDQg").build()
app.add_handler(MessageHandler(filters.ALL, get_file_id))
app.run_polling()

---- bot\keyboards.py ----
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_cancel_kb():
    kb = [
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_country_kb():
    """Клавиатура выбора страны"""
    kb = [
        [KeyboardButton(text="🇧🇾"), KeyboardButton(text="🇷🇺")],       
        [KeyboardButton(text="🇰🇿"), KeyboardButton(text="🇦🇲")],        
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_user_type_kb():
    """Клавиатура выбора типа пользователя"""
    kb = [
        [KeyboardButton(text="👨‍⚕️ Ветеринарный врач клиники-партнера")],
        [KeyboardButton(text="🔬 Сотрудник VET UNION")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_specialization_kb():
    """Клавиатура выбора специализации для ветеринарных врачей"""
    kb = [
        [KeyboardButton(text="🏥 Общая практика")],
        [KeyboardButton(text="🦠 Дерматолог"), KeyboardButton(text="🎗️ Онколог")],
        [KeyboardButton(text="🔬 Лаборант"), KeyboardButton(text="🦠 Инфекционист")],
        [KeyboardButton(text="🍽️ Гастроэнтеролог"), KeyboardButton(text="❤️ Кардиолог")],
        [KeyboardButton(text="🦴 Ортопед"), KeyboardButton(text="🌿 Реабилитолог")],
        [KeyboardButton(text="✏️ Ввести свою специализацию")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_region_kb():
    """Клавиатура выбора региона для сотрудников"""
    kb = [
        [KeyboardButton(text="📍 Москва"), KeyboardButton(text="📍 Московская область")],
        [KeyboardButton(text="📍 Санкт-Петербург"), KeyboardButton(text="📍 Ленинградская область")],
        [KeyboardButton(text="📍 Новосибирск"), KeyboardButton(text="📍 Новосибирская область")],
        [KeyboardButton(text="📍 Екатеринбург"), KeyboardButton(text="📍 Свердловская область")],
        [KeyboardButton(text="📍 Казань"), KeyboardButton(text="📍 Татарстан")],
        [KeyboardButton(text="📍 Краснодар"), KeyboardButton(text="📍 Краснодарский край")],
        [KeyboardButton(text="✏️ Ввести свой регион")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_department_function_kb():
    """Клавиатура выбора функции сотрудника"""
    kb = [
        [KeyboardButton(text="🔬 Лаборатория")],
        [KeyboardButton(text="💰 Продажи")],
        [KeyboardButton(text="🤝 Поддержка")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_main_menu_kb():
    """Единое меню для всех пользователей (кроме админа)"""
    kb = [
        [KeyboardButton(text="❓ Задать вопрос")],
        [KeyboardButton(text="📞 Обратная связь")],
        [KeyboardButton(text="💡 Предложения и пожелания")],
        [KeyboardButton(text="🔑 Активировать код")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_admin_menu_kb():
    """Меню для администраторов"""
    kb = [
        [KeyboardButton(text="📊 Статистика"), KeyboardButton(text="👥 Пользователи")],
        [KeyboardButton(text="📋 Все обращения"), KeyboardButton(text="🔐 Создать код")],
        [KeyboardButton(text="❓ Задать вопрос"), KeyboardButton(text="📞 Обратная связь")],
        [KeyboardButton(text="💡 Предложения и пожелания")],
        [KeyboardButton(text="🔧 Управление системой")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_phone_kb():
    kb = [
        [KeyboardButton(text="📱 Поделиться номером", request_contact=True)],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_feedback_type_kb():
    kb = [
        [KeyboardButton(text="💡 Предложение"), KeyboardButton(text="⚠️ Жалоба")],
        [KeyboardButton(text="❌ Отмена")]
    ]
    return ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

def get_menu_by_role(role: str):
    """Получить меню в зависимости от роли"""
    if role == 'admin':
        return get_admin_menu_kb()
    else:
        return get_main_menu_kb()
    
def get_dialog_kb():
    """Клавиатура для режима диалога с ботом."""
    return ReplyKeyboardMarkup(
        keyboard=[
#            [KeyboardButton(text="❓ Задать еще вопрос")],  # Более понятная формулировка
            [KeyboardButton(text="🔄 Новый вопрос")],
            [KeyboardButton(text="❌ Завершить диалог")]
        ],
        resize_keyboard=True,
        one_time_keyboard=False
    )

# Для совместимости
get_client_menu_kb = get_main_menu_kb
get_staff_menu_kb = get_main_menu_kb

---- bot\__init__.py ----

---- bot\handlers\activation.py ----
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_admin_menu_kb, get_main_menu_kb

from src.database.db_init import db

activation_router = Router()

class ActivationStates(StatesGroup):
    waiting_for_code = State()

@activation_router.message(F.text == "🔑 Активировать код")
async def start_activation(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Необходимо пройти регистрацию. Используйте /start")
        return
    
    if user['role'] == 'admin':
        await message.answer(
            "Вы уже являетесь администратором!",
            reply_markup=get_admin_menu_kb()
        )
        return
    
    await message.answer(
        "Введите код активации администратора:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(ActivationStates.waiting_for_code)

@activation_router.message(ActivationStates.waiting_for_code)
async def process_activation_code(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "❌ Отмена":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_main_menu_kb())
        return
    
    code = message.text.strip().upper()
    activation = await db.check_activation_code(code)
    
    if activation:
        await db.use_activation_code(code, user_id)
        await db.update_user_role(user_id, 'admin')
        
        await message.answer(
            "✅ Код успешно активирован!\n"
            "Теперь вы администратор системы.",
            reply_markup=get_admin_menu_kb()
        )
    else:
        await message.answer(
            "❌ Неверный или уже использованный код.\n"
            "Попробуйте еще раз или нажмите Отмена.",
            reply_markup=get_cancel_kb()
        )
        return
    
    await state.clear()

---- bot\handlers\admin.py ----
import random
import string
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_admin_menu_kb, get_main_menu_kb

from src.database.db_init import db

admin_router = Router()

class ActivationStates(StatesGroup):
    waiting_for_code = State()

@admin_router.message(F.text == "🔑 Активировать код")
async def start_activation(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Необходимо пройти регистрацию. Используйте /start")
        return
    
    if user['role'] == 'admin':
        await message.answer(
            "Вы уже являетесь администратором!",
            reply_markup=get_admin_menu_kb()
        )
        return
    
    await message.answer(
        "Введите код активации администратора:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(ActivationStates.waiting_for_code)

@admin_router.message(ActivationStates.waiting_for_code)
async def process_activation_code(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "❌ Отмена":
        await state.clear()
        await message.answer("Операция отменена.", reply_markup=get_main_menu_kb())
        return
    
    code = message.text.strip().upper()
    activation = await db.check_activation_code(code)
    
    if activation:
        await db.use_activation_code(code, user_id)
        await db.update_user_role(user_id, 'admin')
        
        await message.answer(
            "✅ Код успешно активирован!\n"
            "Теперь вы администратор системы.",
            reply_markup=get_admin_menu_kb()
        )
    else:
        await message.answer(
            "❌ Неверный или уже использованный код.\n"
            "Попробуйте еще раз или нажмите Отмена.",
            reply_markup=get_cancel_kb()
        )
        return
    
    await state.clear()

@admin_router.message(F.text == "🔐 Создать код")
async def create_code(message: Message):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    # Генерируем случайный код только для админа
    code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
    admin_code = f"ADMIN{code}"
    
    await db.create_admin_code(admin_code)
    
    await message.answer(
        "✅ Код активации создан:\n\n"
        f"👨‍💼 Для администратора: `{admin_code}`\n\n"
        "Код одноразовый и действует бессрочно.",
        parse_mode="Markdown",
        reply_markup=get_admin_menu_kb()
    )

@admin_router.message(F.text == "📊 Статистика")
async def show_stats(message: Message):
    user_id = message.from_user.id
    
    user = await db.get_user(user_id)
    
    if not user or user['role'] != 'admin':
        await message.answer("У вас нет доступа к этой функции.")
        return
    
    stats = await db.get_statistics()
    
    await message.answer(
        f"📊 Статистика системы:\n\n"
        f"👥 Всего пользователей: {stats['total_users']}\n"
        f"├ Клиентов (вет.врачей): {stats['clients']}\n"
        f"├ Сотрудников: {stats['employees']}\n"
        f"└ Администраторов: {stats['admins']}\n\n"
        f"📋 Обращений: {stats['total_requests']}\n"
        f"❓ Вопросов: {stats['questions']}\n"
        f"📞 Звонков: {stats['callbacks']}\n"
        f"💡 Предложений: {stats['suggestions']}\n"
        f"⚠️ Жалоб: {stats['complaints']}",
        reply_markup=get_admin_menu_kb()
    )

---- bot\handlers\feedback.py ----
import re
import asyncio
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_menu_by_role, get_phone_kb, get_feedback_type_kb
from utils.email_sender import send_callback_email, send_feedback_email

from src.database.db_init import db

feedback_router = Router()

class CallbackStates(StatesGroup):
    waiting_for_phone = State()
    waiting_for_message = State()

class FeedbackStates(StatesGroup):
    waiting_for_type = State()
    waiting_for_message = State()

def format_phone_number(phone: str, country: str = 'BY'):
    """Форматирование телефонного номера с учетом страны"""
    digits = re.sub(r'\D', '', phone)
    
    if country == 'BY':
        # Добавляем код страны если его нет
        if len(digits) == 9:
            digits = '375' + digits
        if len(digits) == 12 and digits.startswith('375'):
            return f"+{digits[:3]} ({digits[3:5]}) {digits[5:8]}-{digits[8:10]}-{digits[10:12]}"
    
    elif country == 'RU':
        # Для России
        if len(digits) == 10:
            digits = '7' + digits
        elif len(digits) == 11 and digits.startswith('8'):
            digits = '7' + digits[1:]
        if len(digits) == 11 and digits.startswith('7'):
            return f"+{digits[0]} ({digits[1:4]}) {digits[4:7]}-{digits[7:9]}-{digits[9:11]}"
    
    elif country == 'KZ':
        # Для Казахстана
        if len(digits) == 10 and digits.startswith('7'):
            digits = '7' + digits
        elif len(digits) == 11 and digits.startswith('8'):
            digits = '7' + digits[1:]
        if len(digits) == 11 and digits.startswith('77'):
            return f"+{digits[0]} ({digits[1:4]}) {digits[4:7]}-{digits[7:9]}-{digits[9:11]}"
    elif country == 'AM':
        # Для Армении
        if len(digits) == 8:
            digits = '374' + digits
        if len(digits) == 11 and digits.startswith('374'):
            return f"+{digits[:3]} ({digits[3:5]}) {digits[5:8]}-{digits[8:11]}" 
    return phone  

def validate_phone_number(phone: str, country: str = 'BY'):
    """Валидация телефонного номера с учетом страны"""
    digits = re.sub(r'\D', '', phone)
    
    if country == 'BY':
        # Беларусь: +375 XX XXX-XX-XX
        return bool(re.match(r'^(375)?[0-9]{9}$', digits))
    elif country == 'RU':
        # Россия: +7 XXX XXX-XX-XX
        return bool(re.match(r'^[78]?[0-9]{10}$', digits))
    elif country == 'KZ':
        # Казахстан: +7 7XX XXX-XX-XX
        return bool(re.match(r'^[78]?7[0-9]{9}$', digits))
    elif country == 'AM':
        # Армения: +374 XX XXX-XXX
        return bool(re.match(r'^(374)?[0-9]{8}$', digits))
    return False

@feedback_router.message(F.text == "📞 Обратная связь")
async def request_callback(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user = await db.get_user(user_id)
    
    if not user:
        await message.answer("Для использования этой функции необходимо пройти регистрацию.\nИспользуйте команду /start")
        return

    # Получаем страну пользователя
    country = user['country'] if 'country' in user.keys() else 'BY'
    await state.update_data(user_country=country)
    
    # Формируем подсказку по формату
    phone_formats = {
        'BY': "+375 (XX) XXX-XX-XX",
        'RU': "+7 (XXX) XXX-XX-XX",
        'KZ': "+7 (7XX) XXX-XX-XX",
        'AM': "+374 (XX) XXX-XXX"
    }
    
    format_hint = phone_formats.get(country, phone_formats['BY'])
    
    await message.answer(
        f"📞 Заказ обратного звонка\n\n"
        f"Пожалуйста, отправьте ваш номер телефона или введите вручную.\n"
        f"Формат для вашей страны: {format_hint}",
        reply_markup=get_phone_kb()
    )
    await state.set_state(CallbackStates.waiting_for_phone)

@feedback_router.message(CallbackStates.waiting_for_phone)
async def process_phone(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Отмена":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        return

    data = await state.get_data()
    country = data.get('user_country', 'BY')
    phone = ""

    if message.contact:
        phone = message.contact.phone_number
        if not phone.startswith('+'):
            phone = '+' + phone
    else:
        phone = message.text
        if not validate_phone_number(phone, country):
            phone_examples = {
                'BY': "375291234567 или +375 29 123-45-67",
                'RU': "79123456789 или +7 912 345-67-89",
                'KZ': "77012345678 или +7 701 234-56-78",
                'AM': "37477123456 или +374 77 123-456"
            }
            example = phone_examples.get(country, phone_examples['BY'])
            
            await message.answer(
                f"❌ Неверный формат номера телефона.\n"
                f"Пожалуйста, введите номер в формате:\n"
                f"{example}",
                reply_markup=get_phone_kb()
            )
            return
        
        phone = format_phone_number(phone, country)

    await state.update_data(phone=phone)
    await message.answer(
        "Отлично! Теперь напишите ваше сообщение.\n"
        "Опишите причину обращения, удобное время для звонка и любую другую важную информацию:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(CallbackStates.waiting_for_message)

@feedback_router.message(CallbackStates.waiting_for_message)
async def process_callback_message(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Отмена":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        print(f"[INFO] User {user_id} cancelled callback message")
        return

    data = await state.get_data()
    phone = data.get('phone')
    user = await db.get_user(user_id)
    
    # Преобразуем Row в словарь
    user_dict = dict(user) if user else {}

    print(f"[INFO] Sending callback email for user {user_id}")
    email_sent = await send_callback_email(user_dict, phone, message.text)

    if email_sent:
        print(f"[INFO] Callback email sent for user {user_id}")
    else:
        print(f"[WARN] Callback email failed for user {user_id}, fallback to acceptance message")

    await db.add_request_stat(user_id, "callback_request", f"Телефон: {phone}, Сообщение: {message.text[:100]}...")
    print(f"[INFO] Callback stat saved for user {user_id}")

    user_role = user['role'] if user else 'user'
    await message.answer(
        "✅ Ваша заявка на обратный звонок успешно отправлена!\n\n"
        f"📞 Телефон: {phone}\n💬 Сообщение: {message.text}\n\n"
        "Наш администратор свяжется с вами в ближайшее время.",
        reply_markup=get_menu_by_role(user_role)
    )
    await state.clear()
    print(f"[INFO] State cleared for user {user_id}")

@feedback_router.message(F.text == "💡 Предложения и пожелания")
async def start_feedback(message: Message, state: FSMContext):
    user_id = message.from_user.id
    print(f"[INFO] User {user_id} requested feedback submission")

    user = await db.get_user(user_id)
    if not user:
        print(f"[WARN] User {user_id} not registered, prompting /start")
        await message.answer("Для использования этой функции необходимо пройти регистрацию.\nИспользуйте команду /start")
        return

    await message.answer("Выберите тип обращения:", reply_markup=get_feedback_type_kb())
    await state.set_state(FeedbackStates.waiting_for_type)
    print(f"[INFO] State set to waiting_for_type for user {user_id}")

@feedback_router.message(FeedbackStates.waiting_for_type)
async def process_feedback_type(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Отмена":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        print(f"[INFO] User {user_id} cancelled feedback type selection")
        return

    if message.text not in ["💡 Предложение", "⚠️ Жалоба"]:
        print(f"[WARN] User {user_id} entered invalid feedback type: {message.text}")
        await message.answer("Пожалуйста, выберите тип обращения из предложенных вариантов.", reply_markup=get_feedback_type_kb())
        return

    feedback_type = "suggestion" if message.text == "💡 Предложение" else "complaint"
    await state.update_data(feedback_type=feedback_type)
    print(f"[INFO] User {user_id} selected feedback type: {feedback_type}")

    await message.answer(
        f"Вы выбрали: {message.text}\n\n"
        "Пожалуйста, опишите ваше обращение подробно:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(FeedbackStates.waiting_for_message)
    print(f"[INFO] State set to waiting_for_message for user {user_id}")

@feedback_router.message(FeedbackStates.waiting_for_message)
async def process_feedback_message(message: Message, state: FSMContext):
    user_id = message.from_user.id

    if message.text == "❌ Отмена":
        await state.clear()
        user = await db.get_user(user_id)
        user_role = user['role'] if user else 'user'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(user_role))
        print(f"[INFO] User {user_id} cancelled feedback message")
        return

    data = await state.get_data()
    feedback_type = data.get('feedback_type')
    user = await db.get_user(user_id)
    
    # Преобразуем Row в словарь
    user_dict = dict(user) if user else {}

    await db.add_feedback(user_id=user_id, feedback_type=feedback_type, message=message.text)
    print(f"[INFO] Feedback saved to DB for user {user_id}")

    await send_feedback_email(user_dict, feedback_type, message.text)
    print(f"[INFO] Feedback email sent for user {user_id}")

    type_text = "предложение" if feedback_type == "suggestion" else "жалоба"
    user_role = user['role'] if user else 'user'
    await message.answer(
        f"✅ Ваше {type_text} успешно отправлено!\n\n"
        "Мы обязательно рассмотрим ваше обращение и примем необходимые меры.\nСпасибо за обратную связь!",
        reply_markup=get_menu_by_role(user_role)
    )
    await state.clear()
    print(f"[INFO] State cleared for user {user_id}")

---- bot\handlers\help.py ----
# bot/handlers/help.py
from aiogram import Router, F
from aiogram.types import Message
from bot.keyboards import get_dialog_kb

help_router = Router()

@help_router.message(F.text == "❓ Помощь по функциям")
async def show_function_help(message: Message):
    """Показывает справку по доступным функциям диалога"""
    help_text = """
    Доступные команды в диалоге:
    
    🔄 Новый вопрос - начать новый диалог с нейросетью
    ❌ Завершить диалог - вернуться в главное меню
    ❓ Помощь по функциям - эта справка
    
    В режиме диалога вы можете:
    • Задавать уточняющие вопросы по предыдущему запросу
    • Получать дополнительную информацию
    • Уточнять детали ответа
    
    Для нового поиска информации используйте "🔄 Новый вопрос"
    """
    await message.answer(help_text, reply_markup=get_dialog_kb())

---- bot\handlers\questions.py ----
from aiogram import Router, F
from aiogram.types import Message, BufferedInputFile
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import get_cancel_kb, get_menu_by_role, get_dialog_kb
from src.database.db_init import db
from src.data_vectorization import DataProcessor
from models.models_init import qwen3_32b_instruct_free as llm
from langchain.schema import SystemMessage, HumanMessage
import asyncio
import json
import re
import base64

# GIF file_id для анимации загрузки (опционально)
LOADING_GIF_ID = "CgACAgIAAxkBAAMIaGr_qy1Wxaw2VrBrm3dwOAkYji4AAu54AAKmqHlJAtZWBziZvaA2BA"

questions_router = Router()

class QuestionStates(StatesGroup):
    waiting_for_question = State()
    in_dialog = State()

@questions_router.message(F.text.in_(["❓ Задать вопрос", "🤖 Вопрос нейросети"]))
async def start_question(message: Message, state: FSMContext):
    """Begin question flow and reset ephemeral memory buffer."""
    user_id = message.from_user.id
    print(f"[INFO] User {user_id} initiated question flow")

    user = await db.get_user(user_id)
    if not user:
        print(f"[WARN] User {user_id} not registered")
        await message.answer(
            "Для использования этой функции необходимо пройти регистрацию.\n"
            "Используйте команду /start"
        )
        return

    role = user['role'] if 'role' in user else 'client'
    print(f"[INFO] Resolved role for user {user_id}: {role}")

    await db.clear_buffer(user_id)

    prompt = (
        "🤖 Задайте ваш профессиональный вопрос нейросети.\n\n"
        "Я могу помочь с:\n"
        "• Информацией о тестах и анализах\n"
        "• Преаналитическими требованиями\n"
        "• Общими вопросами по лабораторной диагностике\n"
        "Клиент\n"
        if role == 'staff' else
        "🤖 Задайте ваш профессиональный вопрос нейросети.\n\n"
        "Я могу помочь с:\n"
        "• Информацией о тестах и анализах\n"
        "• Преаналитическими требованиями\n"
        "• Общими вопросами по лабораторной диагностике"
    )

    await message.answer(prompt, reply_markup=get_cancel_kb())
    await state.set_state(QuestionStates.waiting_for_question)
    print(f"[INFO] State set to waiting_for_question for user {user_id}")

@questions_router.message(QuestionStates.waiting_for_question)
async def process_question(message: Message, state: FSMContext):
    """Handle user question: update memory, fetch RAG context, ask LLM, update memory."""
    user_id = message.from_user.id
    text = message.text.strip()

    if text == "❌ Отмена":
        await state.clear()
        user = await db.get_user(user_id)
        role = user['role'] if 'role' in user else 'client'
        await message.answer("Операция отменена.", reply_markup=get_menu_by_role(role))
        print(f"[INFO] User {user_id} cancelled question")
        return

    user = await db.get_user(user_id)
    role = user['role'] if 'role' in user else 'client'
    print(f"[INFO] User {user_id} submitted question: {text} (role={role})")

    # Store the original question in the state for follow-ups
    await state.update_data(original_question=text)

    # Отправляем анимированное сообщение о загрузке
    loading_msg = await message.answer_animation(
        animation=LOADING_GIF_ID,
        caption="🤖 Обрабатываю ваш запрос...\n⏳ Анализирую данные..."
    )
    
    # Создаем задачу для анимации загрузки
    animation_task = asyncio.create_task(animate_loading(loading_msg))
    
    try:
        # Process the question with RAG
        answer = await process_user_question(user_id, text, role, is_new_question=True)
        
        # Останавливаем анимацию и удаляем сообщение
        animation_task.cancel()
        try:
            await loading_msg.delete()
        except:
            pass
        
        await message.answer(answer, reply_markup=get_dialog_kb())
        await state.set_state(QuestionStates.in_dialog)
        print(f"[INFO] State set to in_dialog for user {user_id}")
        
    except Exception as e:
        print(f"[ERROR] Error processing question for user {user_id}: {e}")
        animation_task.cancel()
        try:
            await loading_msg.delete()
        except:
            pass
        
        await message.answer(
            "❌ Произошла ошибка при обработке вашего вопроса.\n"
            "Пожалуйста, попробуйте еще раз или обратитесь в поддержку.",
            reply_markup=get_menu_by_role(role)
        )
        await state.clear()

# @questions_router.message(
#     QuestionStates.in_dialog, 
#     F.text.regexp(r'(?i)(фото|покажи|дай).*(контейнер|пробирк|тест|анализ)'),
#     flags={"priority": 10}
# )
# async def send_container_image(message: Message, state: FSMContext):
#     """Send container image when specifically requested."""
#     user_id = message.from_user.id
#     processor = DataProcessor()
#     processor.load_vector_store()
    
#     # Get last question from state
#     data = await state.get_data()
#     question = data.get('original_question', '')
    
#     # Search for relevant test
#     hits = processor.search_test(question, top_k=1)
#     if not hits:
#         await message.answer("Не удалось найти информацию о контейнере.")
#         return
    
#     doc = hits[0][0]  # Get the document from search results
    
#     if 'container_image_base64' not in doc.metadata:
#         await message.answer("Изображение контейнера недоступно для этого теста.")
#         return
    
#     try:
#         image_data = doc.metadata['container_image_base64']
#         if ';base64,' in image_data:
#             image_data = image_data.split(';base64,')[-1]
        
#         image_bytes = base64.b64decode(image_data)
#         await message.answer_photo(
#             BufferedInputFile(image_bytes, "container.jpg"),
#             caption=f"Контейнер для теста: {doc.page_content}"
#         )
#     except Exception as e:
#         await message.answer(f"Ошибка при отправке изображения: {str(e)}")

@questions_router.message(QuestionStates.in_dialog)
async def handle_dialog(message: Message, state: FSMContext):
    """Handle follow-up questions in dialog mode."""
    user_id = message.from_user.id
    text = message.text.strip()

    if text == "❌ Завершить диалог":
        await state.clear()
        user = await db.get_user(user_id)
        role = user['role'] if 'role' in user else 'client'
        await message.answer("Диалог завершен.", reply_markup=get_menu_by_role(role))
        print(f"[INFO] User {user_id} ended dialog")
        return
    
    if text == "🔄 Новый вопрос":
        await db.clear_buffer(user_id)
        await message.answer("Задайте новый вопрос:", reply_markup=get_cancel_kb())
        await state.set_state(QuestionStates.waiting_for_question)
        print(f"[INFO] User {user_id} started new question")
        return

    # Get the original question from the state
    data = await state.get_data()
    original_question = data.get('original_question', '')

    user = await db.get_user(user_id)
    role = user['role'] if 'role' in user else 'client'
    print(f"[INFO] User {user_id} asked follow-up: {text} (role={role})")

    # Process follow-up without RAG (reuse original question context)
    answer = await process_user_question(user_id, text, role, is_new_question=False)
    
    await message.answer(answer, reply_markup=get_dialog_kb())
    print(f"[INFO] Follow-up answer sent to user {user_id}")
    
async def animate_loading(message: Message):
    """Анимация загрузки через редактирование подписи к GIF"""
    animations = [
        "🤖 Обрабатываю ваш запрос...\n⏳ Анализирую данные...",
        "🤖 Обрабатываю ваш запрос...\n🔍 Поиск в базе знаний...",
        "🤖 Обрабатываю ваш запрос...\n🧠 Формирую ответ...",
        "🤖 Обрабатываю ваш запрос...\n📝 Подготавливаю результат..."
    ]
    
    i = 0
    try:
        while True:
            await asyncio.sleep(2)
            i = (i + 1) % len(animations)
            await message.edit_caption(caption=animations[i])  # Изменено с edit_text на edit_caption
    except asyncio.CancelledError:
        pass
    except Exception:
        pass

async def process_user_question(user_id: int, text: str, role: str, is_new_question: bool) -> str:
    """Process user question and return AI response."""
    await db.add_request_stat(user_id, "question", text[:200])
    await db.add_memory(user_id, 'buffer', f"User: {text}")

    summary = await db.get_latest_summary(user_id) or ""
    buffer = await db.get_buffer(user_id)

    rag_context = ""
    rag_hits = []  # Initialize empty list for follow-ups
    
    if is_new_question:
        processor = DataProcessor()
        processor.load_vector_store()
        rag_hits = processor.search_test(text, top_k=5)

        rag_blocks = []
        for doc, score in rag_hits:
            clean_meta = {k: v for k, v in doc.metadata.items() if k != 'container_image_base64'}
            meta_json = json.dumps(clean_meta, ensure_ascii=False, sort_keys=True)
            rag_blocks.append(f"Тест: {doc.page_content}\nМетаданные: {meta_json}")
        rag_context = "\n\n---\n\n".join(rag_blocks)

    memory_section = ""
    if summary:
        memory_section += f"Сводка предыдущих сообщений: {summary}\n\n"
    if buffer:
        memory_section += "Последние сообщения:\n" + "\n".join(buffer) + "\n\n"

    system_msg = SystemMessage(
        content="Ты — ветеринарный помощник. Используй память и преаналитическую информацию для ответа. Если информации нет - честно скажи об этом. Используй форматирование: **жирный** для важного, _курсив_ для терминов. Будь кратким и профессиональным. Делай приятное оформление для телеграмм. Без использования Markdown"
    )
    user_msg = HumanMessage(
        content=(
            f"{memory_section}"
            f"Контекст преаналитики:\n{rag_context}\n\n"
            f"Вопрос пользователя: {text}\n\n"
            "Ответь на русском языке, кратко и по делу."
        )
    )

    print(f"[INFO] Sending prompt to LLM for user {user_id}")
    response = await llm.agenerate([[system_msg, user_msg]])

    def markdown_to_html(text: str) -> str:
        """Convert basic Markdown to Telegram-compatible HTML."""
        # Bold: **text** -> <b>text</b>
        text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
        # Italic: _text_ -> <i>text</i>
        text = re.sub(r'_(.+?)_', r'<i>\1</i>', text)
        # Code: `text` -> <code>text</code>
        text = re.sub(r'`(.+?)`', r'<code>\1</code>', text)
        return text

    answer = response.generations[0][0].text.strip()
    print(f"[INFO] Received LLM answer for user {user_id}")
    answer = markdown_to_html(answer)  # Convert Markdown to HTML
    print(f"[INFO] Converted Markdown to HTML for user {user_id}")
    await db.add_memory(user_id, 'buffer', f"Bot: {answer}")
    print(f"[INFO] Bot response buffered for user {user_id}")

    return answer

---- bot\handlers\registration.py ----
import re
from aiogram import Router, F
from aiogram.types import Message, ReplyKeyboardRemove
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from bot.keyboards import (
    get_cancel_kb, get_user_type_kb, get_department_function_kb, 
    get_main_menu_kb, get_admin_menu_kb, get_specialization_kb,
    get_region_kb, get_country_kb
)

from src.database.db_init import db

registration_router = Router()

class RegistrationStates(StatesGroup):
    waiting_for_user_type = State()
    waiting_for_country = State()  # Новое состояние
    # Для клиентов
    waiting_for_client_code = State()
    waiting_for_client_name = State()
    waiting_for_specialization = State()
    waiting_for_custom_specialization = State()
    # Для сотрудников
    waiting_for_region = State()
    waiting_for_custom_region = State()
    waiting_for_employee_name = State()
    waiting_for_department = State()

@registration_router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    user_id = message.from_user.id
    print(f"[INFO] User {user_id} initiated registration")

    await state.clear()
    user_exists = await db.user_exists(user_id)

    if user_exists:
        print(f"[INFO] User {user_id} already registered")
        user = await db.get_user(user_id)
        menu_kb = get_admin_menu_kb() if user['role'] == 'admin' else get_main_menu_kb()
        await message.answer(
            "Вы уже зарегистрированы! 🎉\n"
            "Используйте меню для дальнейшей работы.",
            reply_markup=menu_kb
        )
    else:
        print(f"[INFO] User {user_id} starting new registration")
        await message.answer(
            "Добро пожаловать в бот Лаборатории VET UNION! 🧪\n\n"
            "Для начала работы необходимо пройти регистрацию.\n"
            "Выберите, кто вы:",
            reply_markup=get_user_type_kb()
        )
        await state.set_state(RegistrationStates.waiting_for_user_type)

@registration_router.message(StateFilter(RegistrationStates), F.text == "❌ Отмена")
async def cancel_registration(message: Message, state: FSMContext):
    user_id = message.from_user.id
    await state.clear()
    await message.answer(
        "Регистрация отменена. Для начала регистрации используйте /start",
        reply_markup=ReplyKeyboardRemove()
    )
    print(f"[INFO] User {user_id} cancelled registration")

@registration_router.message(RegistrationStates.waiting_for_user_type)
async def process_user_type(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "👨‍⚕️ Ветеринарный врач клиники-партнера":
        await state.update_data(user_type='client')
    elif message.text == "🔬 Сотрудник VET UNION":
        await state.update_data(user_type='employee')
    else:
        await message.answer(
            "❌ Пожалуйста, выберите из предложенных вариантов",
            reply_markup=get_user_type_kb()
        )
        return
    
    # Переходим к выбору страны
    await message.answer(
        "🌍 В какой стране вы находитесь?",
        reply_markup=get_country_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_country)
    
@registration_router.message(RegistrationStates.waiting_for_country)
async def process_country(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    country_map = {
        "🇧🇾": "BY",
        "🇷🇺": "RU",
        "🇰🇿": "KZ",
        "🇦🇲": "AM"
    }
    
    if message.text not in country_map:
        await message.answer(
            "❌ Пожалуйста, выберите страну из предложенных вариантов",
            reply_markup=get_country_kb()
        )
        return
    
    country = country_map[message.text]
    await state.update_data(country=country)
    
    # Продолжаем в зависимости от типа пользователя
    data = await state.get_data()
    
    if data['user_type'] == 'client':
        await message.answer(
            "📝 Регистрация ветеринарного врача\n\n"
            "Введите ваш код клиники:\n"
            "⚠️ Код должен начинаться с 'В+' (например: В+МАКСИМА)\n"
            "💡 Код клиники вы можете получить у представителя VET UNION",
            reply_markup=get_cancel_kb()
        )
        await state.set_state(RegistrationStates.waiting_for_client_code)
    else:
        await message.answer(
            "📝 Регистрация сотрудника VET UNION\n\n"
            "Выберите ваш регион:",
            reply_markup=get_region_kb()
        )
        await state.set_state(RegistrationStates.waiting_for_region)

# Обработчики для клиентов
@registration_router.message(RegistrationStates.waiting_for_client_code)
async def process_client_code(message: Message, state: FSMContext):
    user_id = message.from_user.id
    code = message.text.strip().upper()

    if len(code) < 3 or len(code) > 20 or not re.match(r'^[ВB]\+[А-ЯA-Z0-9\-]+$', code):
        await message.answer(
            "❌ Неверный формат кода клиники.\n\n"
            "Код должен:\n"
            "• Начинаться с 'В+'\n"
            "• Содержать только заглавные буквы и цифры\n"
            "• Пример: В+МАКСИМА\n\n"
            "Попробуйте еще раз:"
        )
        return

    await state.update_data(client_code=code)
    await message.answer(
        f"✅ Код клиники: {code}\n\n"
        "Теперь введите ваше имя:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_client_name)

@registration_router.message(RegistrationStates.waiting_for_client_name)
async def process_client_name(message: Message, state: FSMContext):
    name = message.text.strip()

    if len(name) < 2 or len(name) > 50:
        await message.answer(
            "❌ Имя должно содержать от 2 до 50 символов.\nПопробуйте еще раз:"
        )
        return

    await state.update_data(name=name)
    await message.answer(
        f"👤 Имя: {name}\n\n"
        "Выберите вашу специализацию:",
        reply_markup=get_specialization_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_specialization)

@registration_router.message(RegistrationStates.waiting_for_specialization)
async def process_specialization(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if message.text == "✏️ Ввести свою специализацию":
        await message.answer(
            "Введите вашу специализацию:",
            reply_markup=get_cancel_kb()
        )
        await state.set_state(RegistrationStates.waiting_for_custom_specialization)
        return
    
    specialization_map = {
        "🏥 Общая практика": "Общая практика",
        "🦠 Дерматолог": "Дерматолог",
        "🎗️ Онколог": "Онколог",
        "🔬 Лаборант": "Лаборант",
        "🦠 Инфекционист": "Инфекционист",
        "🍽️ Гастроэнтеролог": "Гастроэнтеролог",
        "🌿 Реабилитолог": "Реабилитолог",
        "🦴 Ортопед": "Ортопед",
        "❤️ Кардиолог": "Кардиолог"
    }
    
    if message.text not in specialization_map:
        await message.answer(
            "❌ Пожалуйста, выберите специализацию из списка или введите свою",
            reply_markup=get_specialization_kb()
        )
        return
    
    specialization = specialization_map[message.text]
    data = await state.get_data()
    
    success = await db.add_client(
        telegram_id=user_id,
        name=data['name'],
        client_code=data['client_code'],
        specialization=specialization,
        country=data['country']
    )

    if success:
        await message.answer(
            f"✅ Регистрация завершена успешно!\n\n"
            f"👤 Имя: {data['name']}\n"
            f"🏥 Код клиники: {data['client_code']}\n"
            f"📋 Специализация: {specialization}\n\n"
            "Теперь вы можете пользоваться всеми функциями бота!",
            reply_markup=get_main_menu_kb()
        )
    else:
        await message.answer(
            "❌ Ошибка регистрации. Попробуйте еще раз: /start",
            reply_markup=ReplyKeyboardRemove()
        )

    await state.clear()

@registration_router.message(RegistrationStates.waiting_for_custom_specialization)
async def process_custom_specialization(message: Message, state: FSMContext):
    user_id = message.from_user.id
    specialization = message.text.strip()

    if len(specialization) < 2 or len(specialization) > 100:
        await message.answer(
            "❌ Специализация должна содержать от 2 до 100 символов.\nПопробуйте еще раз:"
        )
        return

    data = await state.get_data()
    
    success = await db.add_client(
        telegram_id=user_id,
        name=data['name'],
        client_code=data['client_code'],
        specialization=specialization,
        country=data['country']
    )

    if success:
        await message.answer(
            f"✅ Регистрация завершена успешно!\n\n"
            f"👤 Имя: {data['name']}\n"
            f"🏥 Код клиники: {data['client_code']}\n"
            f"📋 Специализация: {specialization}\n\n"
            "Теперь вы можете пользоваться всеми функциями бота!",
            reply_markup=get_main_menu_kb()
        )
    else:
        await message.answer(
            "❌ Ошибка регистрации. Попробуйте еще раз: /start",
            reply_markup=ReplyKeyboardRemove()
        )

    await state.clear()

# Обработчики для сотрудников
@registration_router.message(RegistrationStates.waiting_for_region)
async def process_region(message: Message, state: FSMContext):
    if message.text == "✏️ Ввести свой регион":
        await message.answer(
            "Введите ваш регион:",
            reply_markup=get_cancel_kb()
        )
        await state.set_state(RegistrationStates.waiting_for_custom_region)
        return
    
    region_map = {
        "📍 Москва": "Москва",
        "📍 Московская область": "Московская область",
        "📍 Санкт-Петербург": "Санкт-Петербург",
        "📍 Ленинградская область": "Ленинградская область",
        "📍 Новосибирск": "Новосибирск",
        "📍 Новосибирская область": "Новосибирская область",
        "📍 Екатеринбург": "Екатеринбург",
        "📍 Свердловская область": "Свердловская область",
        "📍 Казань": "Казань",
        "📍 Татарстан": "Татарстан",
        "📍 Краснодар": "Краснодар",
        "📍 Краснодарский край": "Краснодарский край"
    }
    
    if message.text not in region_map:
        await message.answer(
            "❌ Пожалуйста, выберите регион из списка или введите свой",
            reply_markup=get_region_kb()
        )
        return
    
    region = region_map[message.text]
    await state.update_data(region=region)
    await message.answer(
        f"📍 Регион: {region}\n\n"
        "Введите вашу фамилию и имя:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_employee_name)

@registration_router.message(RegistrationStates.waiting_for_custom_region)
async def process_custom_region(message: Message, state: FSMContext):
    region = message.text.strip()

    if len(region) < 2 or len(region) > 100:
        await message.answer(
            "❌ Регион должен содержать от 2 до 100 символов.\nПопробуйте еще раз:"
        )
        return

    await state.update_data(region=region)
    await message.answer(
        f"📍 Регион: {region}\n\n"
        "Введите вашу фамилию и имя:",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_employee_name)

@registration_router.message(RegistrationStates.waiting_for_employee_name)
async def process_employee_name(message: Message, state: FSMContext):
    name = message.text.strip()

    if len(name) < 3 or len(name) > 100:
        await message.answer(
            "❌ ФИО должно содержать от 3 до 100 символов.\nПопробуйте еще раз:"
        )
        return

    await state.update_data(name=name)
    await message.answer(
        f"👤 ФИО: {name}\n\n"
        "Выберите функцию, которую вы исполняете:",
        reply_markup=get_department_function_kb()
    )
    await state.set_state(RegistrationStates.waiting_for_department)

@registration_router.message(RegistrationStates.waiting_for_department)
async def process_department(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    department_map = {
        "🔬 Лаборатория": "laboratory",
        "💰 Продажи": "sales",
        "🤝 Поддержка": "support"
    }

    if message.text not in department_map:
        await message.answer(
            "❌ Пожалуйста, выберите функцию из предложенных вариантов",
            reply_markup=get_department_function_kb()
        )
        return

    data = await state.get_data()
    
    success = await db.add_employee(
        telegram_id=user_id,
        name=data['name'],
        region=data['region'],
        department_function=department_map[message.text],
        country=data['country']
    )

    if success:
        await message.answer(
            f"✅ Регистрация завершена успешно!\n\n"
            f"👤 ФИО: {data['name']}\n"
            f"📍 Регион: {data['region']}\n"
            f"🏢 Функция: {message.text}\n\n"
            "Теперь вы можете пользоваться всеми функциями бота!",
            reply_markup=get_main_menu_kb()
        )
    else:
        await message.answer(
            "❌ Ошибка регистрации. Попробуйте еще раз: /start",
            reply_markup=ReplyKeyboardRemove()
        )

    await state.clear()

---- bot\handlers\__init__.py ----
from aiogram import Bot, Dispatcher
from aiogram.enums.parse_mode import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.memory import MemoryStorage

from bot.handlers.registration import registration_router
from bot.handlers.feedback import feedback_router
from bot.handlers.activation import activation_router
from bot.handlers.questions import questions_router
from bot.handlers.admin import admin_router
from bot.handlers.help import help_router
from config import BOT_API_KEY

if not BOT_API_KEY:
    raise RuntimeError('BOT_API_KEY not found.')

bot = Bot(
    token=BOT_API_KEY, 
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher(storage=MemoryStorage())
dp.include_router(registration_router)
dp.include_router(feedback_router)
dp.include_router(activation_router)
dp.include_router(questions_router)
dp.include_router(admin_router)
dp.include_router(help_router)


---- junk\data_preprocessing.py ----
import pandas as pd
from pathlib import Path

def process_excel_file():
    input_path = Path('data/raw/Преаналитика и локализации.xlsx')
    output_path = Path('data/processed/preanalytics_data.xlsx')

    expected_columns = [
        'Код теста', 'Название теста', 'Время голодания',
        'Исследуемый биоматериал', 'Номер контейнера/пробирки/пробирки',
        'Важные ПРЕАНАЛИТИЧЕСКИЕ замечания к тесту к тесту',
        'Тип ПЕРВИЧНОГО контейнера',
        'Тип контейнера для ХРАНЕНИЯ и ТРАНСПОРТИРОВКИ',
        'Температура хранения и транспортировки',
        'Правила взятия и пробоподготовки биоматериала',
        'напрвление исследования'
    ]

    column_rename_map = {
        'Код теста': 'test_code',
        'Название теста': 'test_name',
        'Время голодания': 'fasting_time',
        'Исследуемый биоматериал': 'biomaterial',
        'Номер контейнера/пробирки/пробирки': 'container_id',
        'Важные ПРЕАНАЛИТИЧЕСКИЕ замечания к тесту к тесту': 'preanalytical_notes',
        'Тип ПЕРВИЧНОГО контейнера': 'primary_container',
        'Тип контейнера для ХРАНЕНИЯ и ТРАНСПОРТИРОВКИ': 'storage_transport_container',
        'Температура хранения и транспортировки': 'storage_temperature',
        'Правила взятия и пробоподготовки биоматериала': 'collection_rules',
        'напрвление исследования': 'research_direction'
    }

    xls = pd.ExcelFile(input_path)
    sheets_to_process = [s for s in xls.sheet_names if s != 'Первый лист']

    df_list = []

    for sheet in sheets_to_process:
        df = pd.read_excel(xls, sheet_name=sheet)

        research_col = None
        for col in df.columns:
            if col.strip().lower() == 'исследование':
                research_col = col
                break

        for col in expected_columns:
            if col not in df.columns:
                df[col] = pd.NA

        df = df[expected_columns]
        df = df.rename(columns=column_rename_map)

        if research_col:
            print(f'[INFO] Found extra column "{research_col}" in sheet "{sheet}"')
            alt_names = pd.read_excel(xls, sheet_name=sheet)[research_col].fillna('')
            for i in df.index:
                name = str(df.at[i, 'test_name']) if pd.notna(df.at[i, 'test_name']) else ''
                alt = str(alt_names.iloc[i]).strip()
                if len(alt) > len(name):
                    df.at[i, 'test_name'] = alt

        df['source_sheet'] = sheet
        df_list.append(df)

    combined_df = pd.concat(df_list, ignore_index=True)
    combined_df.dropna(subset=['test_code', 'test_name'], inplace=True)
    combined_df = combined_df[~combined_df['test_name'].astype(str).str.lower().eq('nan')]
    df_unique_code = combined_df.drop_duplicates(subset=['test_code'])
    df_unique_name = combined_df.drop_duplicates(subset=['test_name'])
    combined_df = df_unique_code[df_unique_code.index.isin(df_unique_name.index)]
    output_path.parent.mkdir(parents=True, exist_ok=True)
    combined_df.to_excel(output_path, index=False)
    print(f'[INFO] Saved processed data to {output_path}')

if __name__ == '__main__':
    process_excel_file()

---- models\models_init.py ----
from langchain_community.chat_models import ChatOpenAI

from config import OPENROUTER_API_KEY

MAX_URLS = 5

SEED = 0
TEMPERATURE = 0.7
TOP_P = 1.0


if not OPENROUTER_API_KEY:
    raise RuntimeError('OPENROUTER_API_KEY not found.')

def make_chat(model_name: str, streaming: bool = True) -> ChatOpenAI:
    """
    Helper to instantiate ChatOpenAI with correct kwargs
    """
    return ChatOpenAI(
        model=model_name,
        openai_api_key=OPENROUTER_API_KEY,
        openai_api_base="https://openrouter.ai/api/v1",
        temperature=TEMPERATURE,
        streaming=streaming,
        model_kwargs={"top_p": TOP_P, "seed": SEED},
    )

# FREE models
qwen_coder_32b_instruct_free = make_chat("qwen/qwen-2.5-coder-32b-instruct:free")
qwen3_32b_instruct_free = make_chat("qwen/qwen3-32b:free")
gemma3_27b_instruct_free = make_chat("google/gemma-3-27b-it:free")
qwq_32b_instruct_free = make_chat("qwen/qwq-32b:free")
deepseek_r1_instruct_free = make_chat("deepseek/deepseek-r1:free")
gemini_2_5_pro_exp_free = make_chat("google/gemini-2.5-pro-exp-03-25:free")

# PAYABLE models
gpt_4o = make_chat("openai/gpt-4o", streaming=False)
openai_o1 = make_chat("openai/o1", streaming=False)
openai_o3_mini_high = make_chat("openai/o3-mini-high", streaming=False)
openai_o3_mini = make_chat("openai/o3-mini", streaming=False)
openai_o3 = make_chat("openai/o3", streaming=False)
openai_o1_pro = make_chat("openai/o1-pro", streaming=False)
openai_o1_mini = make_chat("openai/o1-mini", streaming=False)
openai_gpt_4o_search_preview = make_chat("openai/gpt-4o-search-preview", streaming=False)


# additional interesting params (for LLMs)

# max_retries=3,
# max_tokens=150,
# logit_bias={50256: -10}, # (token_id→bias)
# reasoning_effort={"analysis": "high", "summary": "low"},  # max analysis min summary
# cache=None,
# request_timeout=(5.0, 15.0), # (connect, read), sec

---- models\vector_models_init.py ----
import torch
import torch.nn.functional as F
from transformers import AutoTokenizer, AutoModel
from langchain_core.embeddings import Embeddings
from openai import OpenAI
from typing import List
from torch import Tensor
from tqdm import tqdm
import numpy as np

from config import DEEPINFRA_API_KEY

# Device selection
if torch.cuda.is_available():
    device = torch.device('cuda')
elif torch.backends.mps.is_available():
    device = torch.device('mps')
    torch.mps.set_per_process_memory_fraction(0.9)
    torch.mps.empty_cache()
else:
    device = torch.device('cpu')


def get_detailed_instruct(task_description: str, query: str) -> str:
    return f'Instruct: {task_description}\nQuery: {query}'

task_prompt = (
    "You are an embedding model specialized in mapping veterinary "
    "pre-analytical and diagnostic questions to laboratory test names. "
    "Embed the query so that it best matches the correct test title."
)

class QwenEmbeddings(Embeddings):
    def __init__(
        self,
        model_name: str = 'Qwen/Qwen3-Embedding-4B',
        task_prompt: str = task_prompt,
        max_length: int = 8192,
        batch_size: int = 8,
        use_remote: bool = None
    ):
        self.model_name = model_name
        self.task_prompt = task_prompt
        self.max_length = max_length
        self.batch_size = batch_size
        # Determine remote vs local
        if use_remote is None:
            self.use_remote = bool(DEEPINFRA_API_KEY)
        else:
            self.use_remote = use_remote

        if self.use_remote:
            api_key = DEEPINFRA_API_KEY
            if not api_key:
                raise ValueError('DEEPINFRA_API_KEY not set for remote embeddings')
            self.client = OpenAI(
                api_key=api_key,
                base_url='https://api.deepinfra.com/v1/openai'
            )
            print(f'[INFO] Using DeepInfra remote embeddings for model: {model_name}')
        else:
            print(f'[INFO] Using local embeddings for model: {model_name} on device: {device}')
            self.device = device
            self.tokenizer = AutoTokenizer.from_pretrained(model_name, padding_side='left')
            if self.device == torch.device('cuda'):
                self.model = AutoModel.from_pretrained(
                    model_name,
                    attn_implementation='flash_attention_2',
                    torch_dtype=torch.float16,
                    device_map='auto'
                )
            else:
                self.model = AutoModel.from_pretrained(model_name)
                self.model.to(self.device)
            self.model.eval()

    def last_token_pool(self, last_hidden_states: Tensor, attention_mask: Tensor) -> Tensor:
        # same pooling logic
        left_padding = (attention_mask[:, -1].sum() == attention_mask.shape[0])
        if left_padding:
            return last_hidden_states[:, -1]
        else:
            seq_lens = attention_mask.sum(dim=1) - 1
            batch_size = last_hidden_states.shape[0]
            return last_hidden_states[
                torch.arange(batch_size, device=last_hidden_states.device), seq_lens
            ]

    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        return self._encode(texts)

    def embed_query(self, text: str) -> List[float]:
        prompt = get_detailed_instruct(self.task_prompt, text)
        return self._encode([prompt])[0]

    def _encode(self, texts: List[str]) -> List[List[float]]:
        results: List[List[float]] = []
        if self.use_remote: # Remote embedding via DeepInfra/OpenAI client
            batch_size = 200
            for i in tqdm(range(0, len(texts), batch_size), desc='Remote embedding batches'):
                batch_texts = texts[i:i + batch_size]
                # print(f'[INFO] Sending remote batch of size {len(batch_texts)}')
                response = self.client.embeddings.create(
                    model=self.model_name,
                    input=batch_texts,
                    encoding_format='float'
                )
                # Collect embeddings
                vecs = [d.embedding for d in response.data]
                # Normalize
                arr = np.array(vecs, dtype=float)
                norms = np.linalg.norm(arr, axis=1, keepdims=True)
                arr = arr / norms
                results.extend(arr.tolist())
            return results
        else: # Local embedding
            batch_size = self.batch_size
            for i in tqdm(range(0, len(texts), batch_size), desc='Local embedding batches'):
                batch_texts = texts[i:i + batch_size]
                batch = self.tokenizer(
                    batch_texts,
                    padding=True,
                    truncation=True,
                    max_length=self.max_length,
                    return_tensors='pt'
                ).to(self.model.device)

                with torch.no_grad():
                    outputs = self.model(**batch)
                    embeddings = self.last_token_pool(outputs.last_hidden_state, batch['attention_mask'])
                    embeddings = F.normalize(embeddings, p=2, dim=1)

                results.extend(embeddings.cpu().tolist())
            return results


# Instantiate default embedding model (auto-detect)
embedding_model = QwenEmbeddings(model_name='Qwen/Qwen3-Embedding-0.6B', task_prompt=task_prompt, use_remote=True)

---- models\__init__.py ----

---- src\check.py ----
from langchain_community.vectorstores import Chroma
from models.vector_models_init import embedding_model

def main():
    persist_path = "data/chroma_db"

    print(f"[INFO] Loading vector store from {persist_path}")
    vector_store = Chroma(
        embedding_function=embedding_model,
        persist_directory=persist_path
    )

    # Получаем количество документов в векторной базе
    collection = vector_store._collection  # Access underlying chromadb Collection object
    count = collection.count()

    print(f"[INFO] Number of documents in vector store: {count}")

if __name__ == "__main__":
    main()

---- src\data_vectorization.py ----
import os
os.environ['ANONYMIZED_TELEMETRY'] = 'False'
import shutil
import sys
from pathlib import Path
import pandas as pd
from langchain_community.vectorstores import Chroma

project_root = Path(__file__).resolve().parents[1]
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from models.vector_models_init import embedding_model


class DataProcessor:
    def __init__(self, file_path: str = 'data/processed/data.xlsx'):
        self.file_path = Path(file_path)
        self.df = None
        self.vector_store = None
        self.embeddings = embedding_model

    def load_data(self) -> pd.DataFrame:
        if not self.file_path.exists():
            raise FileNotFoundError(f'[ERROR] File not found: {self.file_path}')
        
        print(f'[INFO] Loading data from {self.file_path}')
        self.df = pd.read_excel(self.file_path)
        print(f'[INFO] Loaded {len(self.df)} rows')
        return self.df

    def create_vector_store(self, persist_path: str = "data/chroma_db", reset: bool = False) -> Chroma:
        if self.df is None:
            self.load_data()

        if reset and Path(persist_path).exists():
            print(f'[INFO] Resetting vector store at {persist_path}')
            shutil.rmtree(persist_path)

        print('[INFO] Creating vector store...')
        records = self.df.dropna(subset=["test_name"]).copy()

        texts = records["test_name"].tolist()
        metadatas = records.to_dict(orient="records")

        self.vector_store = Chroma.from_texts(
            texts=texts,
            embedding=self.embeddings,
            metadatas=metadatas,
            persist_directory=persist_path,
            collection_metadata={"hnsw:space": "cosine"}
        )
        self.vector_store.persist()
        print(f'[INFO] Vector store created and persisted at {persist_path}')
        return self.vector_store

    def save_vector_store(self, path: str = "data/chroma_db"):
        if self.vector_store is None:
            raise ValueError("Vector store has not been created yet.")
        self.vector_store.persist()
        print(f'[INFO] Vector store saved to {path}')

    def load_vector_store(self, path: str = "data/chroma_db"):
        print(f'[INFO] Loading vector store from {path}')
        self.vector_store = Chroma(
            embedding_function=self.embeddings,
            persist_directory=path
        )
        return self.vector_store

    def search_test(self, query: str, top_k: int = 3):
        if self.vector_store is None:
            if not self.load_vector_store():
                self.create_vector_store()
        print(f'[INFO] Searching for: "{query}"')
        results = self.vector_store.similarity_search_with_score(query, k=top_k)
        return results
    
    def get_metadata_columns(self) -> list:
        """Get list of metadata columns stored in vector database."""
        if self.vector_store is None:
            self.load_vector_store()
        
        # Get sample document to extract metadata keys
        sample = self.vector_store.get()['metadatas'][0] if self.vector_store.get()['metadatas'] else {}
        return list(sample.keys())


if __name__ == "__main__":
    processor = DataProcessor(file_path='data/processed/data.xlsx')
    processor.create_vector_store(persist_path="data/chroma_db", reset=True)
    print("[INFO] Vector store successfully created and saved.")

---- src\search_test.py ----
import sys
import json

from data_vectorization import DataProcessor

def main():
    if len(sys.argv) < 2:
        print("Usage: python search_test.py 'your query here'")
        return

    query = " ".join(sys.argv[1:])
    print(f'Query: "{query}"')
    processor = DataProcessor()
    processor.load_vector_store()

    results = processor.search_test(query, top_k=3)
    print("\nTop results:")
    for doc, score in results:
        print(f"- Score: {score:.4f} \nText: {doc.page_content} \nMetadata:")
        print(json.dumps(doc.metadata, ensure_ascii=False, indent=4, sort_keys=True))
        print("\n")

if __name__ == "__main__":
    main()

---- src\show_metadata_columns.py ----
from data_vectorization import DataProcessor

def main():
    processor = DataProcessor(file_path='data/processed/data.xlsx')
    processor.load_vector_store() 
    
    columns = processor.get_metadata_columns()
    print("Столбцы метаданных в Chroma:")
    for col in columns:
        print(f"- {col}")

if __name__ == "__main__":
    main()

---- src\database\db_init.py ----
from .models import Database

db = Database('data/vet_clinic.db')

-----------------------------------------------------------------------------------------------------------------------------------------

---- src\database\images_to_base64_match.py ----
import openpyxl
import pandas as pd
import base64
import io
from PIL import Image as PILImage
from pathlib import Path

def extract_images_from_reference_sheet(file_path, sheet_name="Справочник пробирок"):
    """
    Извлекает изображения из листа 'Справочник пробирок' и создает словарь 
    соответствий между типами контейнеров и base64 изображениями
    """
    # Загружаем рабочую книгу
    workbook = openpyxl.load_workbook(file_path)
    worksheet = workbook[sheet_name]
    
    # Словарь для хранения соответствий
    image_dict = {}
    
    # Читаем типы контейнеров из столбца A (начиная со строки 2)
    container_types = {}
    for row in range(2, worksheet.max_row + 1):
        cell_value = worksheet[f'A{row}'].value
        if cell_value and cell_value.strip():
            container_types[row] = cell_value.strip()
    
    print(f"Найдено типов контейнеров: {len(container_types)}")
    for row, container_type in container_types.items():
        print(f"  Строка {row}: {container_type}")
    
    # Получаем все изображения из листа
    images = worksheet._images
    print(f"Найдено изображений в листе: {len(images)}")
    
    # Обрабатываем каждое изображение
    for img_idx, img in enumerate(images):
        try:
            # Получаем позицию изображения
            if hasattr(img.anchor, '_from'):
                # Для newer versions of openpyxl
                row_idx = img.anchor._from.row + 1
                col_idx = img.anchor._from.col + 1
            else:
                # Для older versions
                row_idx = img.anchor.row if hasattr(img.anchor, 'row') else 1
                col_idx = img.anchor.col if hasattr(img.anchor, 'col') else 1
            
            print(f"Изображение {img_idx + 1}: позиция строка {row_idx}, столбец {col_idx}")
            
            # Находим ближайший тип контейнера
            container_type = None
            min_distance = float('inf')
            
            for row_num, c_type in container_types.items():
                distance = abs(row_num - row_idx)
                if distance < min_distance:
                    min_distance = distance
                    container_type = c_type
            
            if container_type and min_distance <= 2:  # Допускаем погрешность в 2 строки
                try:
                    # Получаем данные изображения
                    # img.ref может быть BytesIO объектом или байтами
                    if hasattr(img.ref, 'read'):
                        # Если это BytesIO объект
                        img.ref.seek(0)  # Переходим к началу
                        img_data = img.ref.read()
                    else:
                        # Если это уже байты
                        img_data = img.ref
                    
                    # Конвертируем в PIL Image и затем в base64
                    pil_image = PILImage.open(io.BytesIO(img_data))
                    
                    # Изменяем размер изображения для оптимизации (опционально)
                    max_size = (300, 300)
                    pil_image.thumbnail(max_size, PILImage.Resampling.LANCZOS)
                    
                    # Конвертируем в base64
                    buffered = io.BytesIO()
                    pil_image.save(buffered, format="PNG")
                    img_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                    
                    image_dict[container_type] = img_base64
                    print(f"  Сопоставлено: {container_type} -> изображение {len(img_base64)} символов")
                    
                except Exception as e:
                    print(f"  Ошибка при обработке изображения для {container_type}: {e}")
                    # Попробуем альтернативный способ извлечения
                    try:
                        # Альтернативный способ - через _data атрибут
                        if hasattr(img, '_data'):
                            img_data = img._data
                        elif hasattr(img, 'path'):
                            # Если изображение хранится как файл
                            with open(img.path, 'rb') as f:
                                img_data = f.read()
                        else:
                            print(f"  Не удалось найти данные изображения для {container_type}")
                            continue
                            
                        pil_image = PILImage.open(io.BytesIO(img_data))
                        max_size = (300, 300)
                        pil_image.thumbnail(max_size, PILImage.Resampling.LANCZOS)
                        
                        buffered = io.BytesIO()
                        pil_image.save(buffered, format="PNG")
                        img_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                        
                        image_dict[container_type] = img_base64
                        print(f"  Сопоставлено (альтернативный способ): {container_type} -> изображение {len(img_base64)} символов")
                        
                    except Exception as e2:
                        print(f"  Альтернативный способ тоже не сработал для {container_type}: {e2}")
                        continue
            else:
                print(f"  Не найден подходящий тип контейнера для изображения на позиции {row_idx}")
                
        except Exception as e:
            print(f"Ошибка при обработке изображения {img_idx + 1}: {e}")
            continue
    
    workbook.close()
    return image_dict

def find_matching_image(container_type, image_dict):
    """
    Находит подходящее изображение по вхождению названия
    """
    if not container_type or pd.isna(container_type):
        return None
        
    container_type_clean = str(container_type).strip().lower()
    
    # Сначала ищем точное совпадение
    for ref_type, base64_img in image_dict.items():
        if container_type_clean == ref_type.lower().strip():
            return base64_img
    
    # Затем ищем по вхождению - название из data входит в название из справочника
    for ref_type, base64_img in image_dict.items():
        ref_type_clean = ref_type.lower().strip()
        if container_type_clean in ref_type_clean:
            return base64_img
    
    # Затем ищем обратное вхождение - название из справочника входит в название из data
    for ref_type, base64_img in image_dict.items():
        ref_type_clean = ref_type.lower().strip()
        if ref_type_clean in container_type_clean:
            return base64_img
    
    # Ищем по ключевым словам
    keywords_mapping = {
        'белая': ['белая', 'белой'],
        'красная': ['красная', 'красной', 'гель', 'гелем'],
        'сиреневая': ['сиреневая', 'сиреневой', 'розовая', 'розовой', 'эдта'],
        'желтая': ['желтая', 'желтой', 'моча', 'мочи', 'консервант'],
        'стерильный': ['стерильный', 'стерильной', 'спирт'],
        'кал': ['кал', 'кала', 'ложечка', 'ложечкой'],
        'микро': ['микро', 'транспорт'],
        'стекло': ['стекло', 'предметное'],
        'флакон': ['флакон', 'юнона', 'детский'],
        'amies': ['amies', 'оранжевая', 'оранжевой'],
        'гистолог': ['гистолог', 'histopot'],
        'парафин': ['парафин', 'блок']
    }
    
    for ref_type, base64_img in image_dict.items():
        ref_type_clean = ref_type.lower().strip()
        for keyword, synonyms in keywords_mapping.items():
            if any(syn in container_type_clean for syn in synonyms) and keyword in ref_type_clean:
                return base64_img
    
    return None

def add_base64_to_data_sheet(file_path, image_dict, data_sheet="data"):
    """
    Добавляет столбец с base64 изображениями в лист 'data'
    """
    # Читаем данные из листа 'data'
    df = pd.read_excel(file_path, sheet_name=data_sheet)
    
    print(f"Загружено строк данных: {len(df)}")
    print(f"Столбцы: {list(df.columns)}")
    
    # Создаем новый столбец с base64 изображениями используя функцию поиска по вхождению
    df['container_image_base64'] = df['container_type'].apply(lambda x: find_matching_image(x, image_dict))
    
    # Проверяем результат
    matched = df['container_image_base64'].notna().sum()
    total = len(df)
    print(f"Сопоставлено изображений: {matched} из {total}")
    
    # Показываем детальную статистику сопоставления
    print("\nДетальная статистика сопоставления:")
    container_counts = df['container_type'].value_counts()
    for container_type, count in container_counts.items():
        matched_image = find_matching_image(container_type, image_dict)
        if matched_image:
            # Находим какое именно изображение было сопоставлено
            matched_ref_type = None
            for ref_type, base64_img in image_dict.items():
                if base64_img == matched_image:
                    matched_ref_type = ref_type
                    break
            print(f"  ✓ '{container_type}' -> '{matched_ref_type}' ({count} записей)")
        else:
            print(f"  ✗ '{container_type}' -> НЕ НАЙДЕНО ({count} записей)")
    
    # Сохраняем обновленный файл
    with pd.ExcelWriter(file_path, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
        df.to_excel(writer, sheet_name=data_sheet, index=False)
    
    print(f"\nДанные сохранены в лист '{data_sheet}' с новым столбцом 'container_image_base64'")
    
    return df

def verify_base64_images(df, column='container_image_base64'):
    """
    Проверяет корректность base64 изображений
    """
    print(f"\nПроверка base64 изображений в столбце '{column}':")
    
    valid_count = 0
    invalid_count = 0
    
    for index, row in df.iterrows():
        base64_str = row[column] if column in row else None
        if pd.notna(base64_str) and isinstance(base64_str, str):
            try:
                # Пытаемся декодировать base64
                img_data = base64.b64decode(base64_str)
                
                # Проверяем, что это действительно изображение
                img = PILImage.open(io.BytesIO(img_data))
                valid_count += 1
                
                if index < 5:  # Показываем детали для первых 5 изображений
                    print(f"  Строка {index + 1}: ✓ {img.size} пикселей, формат {img.format}")
                    
            except Exception as e:
                invalid_count += 1
                print(f"  Строка {index + 1}: ✗ Ошибка: {e}")
    
    print(f"\nИтого: {valid_count} корректных изображений, {invalid_count} с ошибками")

# Альтернативная функция для извлечения изображений
def extract_images_alternative_approach(file_path, sheet_name="Справочник пробирок"):
    """
    Альтернативный подход к извлечению изображений - 
    сохраняем Excel как zip и извлекаем изображения из media папки
    """
    import zipfile
    import tempfile
    import os
    import shutil
    
    # Создаем временную папку
    with tempfile.TemporaryDirectory() as temp_dir:
        # Копируем Excel файл как zip
        zip_path = os.path.join(temp_dir, "excel_file.zip")
        shutil.copy2(file_path, zip_path)
        
        try:
            # Извлекаем zip архив
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(temp_dir)
            
            # Ищем папку с изображениями
            media_path = os.path.join(temp_dir, "xl", "media")
            if not os.path.exists(media_path):
                print("Папка с изображениями не найдена")
                return {}
            
            # Загружаем типы контейнеров из Excel
            df_ref = pd.read_excel(file_path, sheet_name=sheet_name)
            container_types = df_ref['Тип контейнера для хранения и транспортировки'].dropna().tolist()
            
            # Получаем все файлы изображений
            image_files = [f for f in os.listdir(media_path) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp'))]
            image_files.sort()  # Сортируем по имени файла
            
            print(f"Найдено файлов изображений: {len(image_files)}")
            print(f"Типов контейнеров: {len(container_types)}")
            
            image_dict = {}
            
            # Сопоставляем изображения с типами контейнеров по порядку
            for i, (image_file, container_type) in enumerate(zip(image_files, container_types)):
                try:
                    image_path = os.path.join(media_path, image_file)
                    
                    # Читаем изображение
                    with open(image_path, 'rb') as f:
                        img_data = f.read()
                    
                    # Конвертируем в PIL Image
                    pil_image = PILImage.open(io.BytesIO(img_data))
                    
                    # Изменяем размер для оптимизации
                    max_size = (300, 300)
                    pil_image.thumbnail(max_size, PILImage.Resampling.LANCZOS)
                    
                    # Конвертируем в base64
                    buffered = io.BytesIO()
                    pil_image.save(buffered, format="PNG")
                    img_base64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                    
                    image_dict[container_type] = img_base64
                    print(f"  Сопоставлено: {container_type} -> {image_file} ({len(img_base64)} символов)")
                    
                except Exception as e:
                    print(f"  Ошибка при обработке {image_file}: {e}")
                    continue
            
            return image_dict
            
        except Exception as e:
            print(f"Ошибка при извлечении из zip: {e}")
            return {}

# Дополнительная функция для анализа совпадений
def analyze_matching_possibilities(file_path, image_dict, data_sheet="data"):
    """
    Анализирует возможные совпадения между названиями из data и справочника
    """
    # Читаем данные из листа 'data'
    df = pd.read_excel(file_path, sheet_name=data_sheet)
    
    # Получаем уникальные типы контейнеров из data
    data_container_types = df['container_type'].dropna().unique()
    
    # Получаем типы из справочника
    ref_container_types = list(image_dict.keys())
    
    print("=== Анализ возможных совпадений ===")
    print(f"Типы контейнеров в data: {len(data_container_types)}")
    print(f"Типы контейнеров в справочнике: {len(ref_container_types)}")
    
    print("\nТипы контейнеров в data:")
    for i, container_type in enumerate(data_container_types, 1):
        print(f"  {i}. {container_type}")
    
    print("\nТипы контейнеров в справочнике:")
    for i, container_type in enumerate(ref_container_types, 1):
        print(f"  {i}. {container_type}")
    
    print("\n=== Возможные совпадения ===")
    
    for data_type in data_container_types:
        data_type_clean = str(data_type).strip().lower()
        found_matches = []
        
        # Точное совпадение
        for ref_type in ref_container_types:
            if data_type_clean == ref_type.lower().strip():
                found_matches.append(('точное', ref_type))
        
        # Вхождение data в ref
        for ref_type in ref_container_types:
            ref_type_clean = ref_type.lower().strip()
            if data_type_clean in ref_type_clean:
                found_matches.append(('data в ref', ref_type))
        
        # Вхождение ref в data
        for ref_type in ref_container_types:
            ref_type_clean = ref_type.lower().strip()
            if ref_type_clean in data_type_clean:
                found_matches.append(('ref в data', ref_type))
        
        if found_matches:
            print(f"\n'{data_type}':")
            for match_type, ref_type in found_matches:
                print(f"  -> {match_type}: '{ref_type}'")
        else:
            print(f"\n'{data_type}': НЕ НАЙДЕНО совпадений")
    
    return data_container_types, ref_container_types

def main():
    project_dir = Path().resolve() # Path(__file__).resolve()
    # project_dir = project_dir.parent.parent
    raw_data_path = project_dir / 'data' / 'raw'
    processed_data_path = project_dir / 'data' / 'processed'
    file_path = raw_data_path / 'ВПР_Полный_перечень_тестов_МДЖ_23_06_ОКОНЧАТЕЛЬНЫЙ.xlsx'
    
    try:
        print("=== Извлечение изображений из справочника пробирок ===")
        
        # Сначала пробуем основной метод
        image_dict = extract_images_from_reference_sheet(file_path)
        
        # Если не получилось, пробуем альтернативный метод
        if not image_dict:
            print("\n=== Пробуем альтернативный метод ===")
            image_dict = extract_images_alternative_approach(file_path)
        
        if not image_dict:
            print("Не удалось извлечь изображения обоими способами.")
            return
        
        print(f"\n=== Найдено изображений: {len(image_dict)} ===")
        for container_type, base64_str in image_dict.items():
            print(f"  {container_type}: {len(base64_str)} символов")
        
        # Анализируем возможные совпадения
        print(f"\n=== Анализ совпадений ===")
        analyze_matching_possibilities(file_path, image_dict)
        
        # Добавляем столбец с base64 в лист "data"
        print(f"\n=== Добавление столбца в лист 'data' ===")
        df = add_base64_to_data_sheet(file_path, image_dict)
        
        # Проверяем результат
        verify_base64_images(df)
        
        print("\n=== Операция завершена успешно! ===")
        
    except Exception as e:
        print(f"Произошла ошибка: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

# Дополнительная функция для отладки - просмотр структуры листа
def debug_sheet_structure(file_path, sheet_name="Справочник пробирок"):
    """
    Отображает структуру листа для отладки
    """
    workbook = openpyxl.load_workbook(file_path)
    worksheet = workbook[sheet_name]
    
    print(f"=== Структура листа '{sheet_name}' ===")
    print(f"Размер листа: {worksheet.max_row} строк x {worksheet.max_column} столбцов")
    print(f"Количество изображений: {len(worksheet._images)}")
    
    # Показываем первые 10 строк
    print("\nПервые 10 строк:")
    for row in range(1, min(11, worksheet.max_row + 1)):
        values = []
        for col in range(1, min(5, worksheet.max_column + 1)):
            cell_value = worksheet.cell(row=row, column=col).value
            values.append(str(cell_value)[:30] if cell_value else "")
        print(f"  Строка {row}: {' | '.join(values)}")
    
    # Информация об изображениях
    print(f"\nИнформация об изображениях:")
    for i, img in enumerate(worksheet._images):
        try:
            if hasattr(img.anchor, '_from'):
                row_idx = img.anchor._from.row + 1
                col_idx = img.anchor._from.col + 1
            else:
                row_idx = "неизвестно"
                col_idx = "неизвестно"
            print(f"  Изображение {i+1}: строка {row_idx}, столбец {col_idx}")
        except Exception as e:
            print(f"  Изображение {i+1}: ошибка определения позиции - {e}")
    
    workbook.close()

# Раскомментируйте для отладки:
# debug_sheet_structure(raw_data_path / 'ВПР_Полный_перечень_тестов_МДЖ_23_06_ОКОНЧАТЕЛЬНЫЙ.xlsx')

---- src\database\models.py ----
# src/database/models.py
import aiosqlite
from datetime import datetime

class Database:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    async def create_tables(self):
        async with aiosqlite.connect(self.db_path) as db:
            # Обновленная таблица пользователей
            await db.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id INTEGER PRIMARY KEY,
                    user_type TEXT CHECK(user_type IN ('client', 'employee')),
                
                    -- Общие поля
                    name TEXT,
                    country TEXT DEFAULT 'BY',  -- Добавляем поле страны
                    registration_date TIMESTAMP,
                    role TEXT DEFAULT 'user',
                    is_active BOOLEAN DEFAULT TRUE,
                
                    -- Поля для клиентов (ветеринарные клиники)
                    client_code TEXT UNIQUE,
                    specialization TEXT,
                
                    -- Поля для сотрудников
                    region TEXT,
                    department_function TEXT CHECK(department_function IN ('laboratory', 'sales', 'support', NULL))
                )
            ''')
            
            # Таблица для жалоб и предложений
            await db.execute('''
                CREATE TABLE IF NOT EXISTS feedback (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    feedback_type TEXT,
                    message TEXT,
                    timestamp TIMESTAMP,
                    status TEXT DEFAULT 'new',
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            # Упрощенная таблица для кодов активации (только для админов)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS activation_codes (
                    code TEXT PRIMARY KEY,
                    role TEXT DEFAULT 'admin',
                    is_used BOOLEAN DEFAULT FALSE,
                    used_by INTEGER,
                    used_at TIMESTAMP,
                    created_at TIMESTAMP
                )
            ''')
            
            # Таблица для статистики запросов
            await db.execute('''
                CREATE TABLE IF NOT EXISTS request_statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    request_type TEXT,
                    request_text TEXT,
                    timestamp TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (telegram_id)
                )
            ''')
            
            # Таблица для памяти разговоров
            await db.execute('''
                CREATE TABLE IF NOT EXISTS conversation_memory (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    type TEXT CHECK(type IN ('buffer','summary')),
                    content TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.commit()
            await self._migrate_database(db)
    
    async def _migrate_database(self, db):
        """Проверка и обновление структуры БД"""
        try:
            # Проверяем существование таблицы
            cursor = await db.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='users'")
            if await cursor.fetchone():
                # Проверяем структуру таблицы
                cursor = await db.execute("PRAGMA table_info(users)")
                columns = await cursor.fetchall()
                column_names = [col[1] for col in columns]
            
                # Если есть старые поля, нужна миграция
                if 'username' in column_names or 'user_type' not in column_names:
                    print("[INFO] Migrating database to new structure...")
                
                    # Создаем временную таблицу с новой структурой
                    await db.execute("DROP TABLE IF EXISTS users_new")
                    await db.execute('''
                        CREATE TABLE users_new (
                            telegram_id INTEGER PRIMARY KEY,
                            user_type TEXT CHECK(user_type IN ('client', 'employee')),
                            name TEXT,
                            country TEXT DEFAULT 'BY',
                            registration_date TIMESTAMP,
                            role TEXT DEFAULT 'user',
                            is_active BOOLEAN DEFAULT TRUE,
                            client_code TEXT UNIQUE,
                            specialization TEXT,
                            region TEXT,
                            department_function TEXT CHECK(department_function IN ('laboratory', 'sales', 'support', NULL))
                        )
                    ''')
                
                    # Копируем данные, адаптируя под новую структуру
                    if 'username' in column_names:
                        await db.execute('''
                            INSERT OR IGNORE INTO users_new (telegram_id, user_type, name, registration_date, role, is_active, client_code)
                            SELECT telegram_id, 'client', username, registration_date, 
                                CASE WHEN role IN ('staff', 'moderator', 'vip') THEN 'user' ELSE role END, 
                                is_active, client_code
                            FROM users
                        ''')
                
                    # Удаляем старую таблицу и переименовываем новую
                    await db.execute("DROP TABLE users")
                    await db.execute("ALTER TABLE users_new RENAME TO users")
                    print("[INFO] Database migration completed")
        
            await db.commit()
        except Exception as e:
            print(f"Migration error: {e}")
            # Если миграция не удалась, создаем таблицу заново
            await db.execute("DROP TABLE IF EXISTS users")
            await db.commit()
    
    async def add_client(self, telegram_id: int, name: str, client_code: str, specialization: str, country: str = 'BY'):
        """Добавление клиента (ветеринарной клиники)"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO users (telegram_id, user_type, name, client_code, 
                                    specialization, country, registration_date, role)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (telegram_id, 'client', name, client_code, specialization, 
                    country, datetime.now(), 'user'))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def add_employee(self, telegram_id: int, name: str, region: str, department_function: str, country: str = 'BY'):
        """Добавление сотрудника"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO users (telegram_id, user_type, name, region, 
                                    department_function, country, registration_date, role)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (telegram_id, 'employee', name, region, department_function, 
                    country, datetime.now(), 'user'))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def get_user(self, telegram_id: int):
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                'SELECT * FROM users WHERE telegram_id = ?', 
                (telegram_id,)
            )
            return await cursor.fetchone()
    
    async def get_user_role(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user['role'] if user else None
    
    async def update_user_role(self, telegram_id: int, role: str):
        """Обновление роли пользователя (только для админа)"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute(
                'UPDATE users SET role = ? WHERE telegram_id = ?',
                (role, telegram_id)
            )
            await db.commit()
    
    async def check_activation_code(self, code: str):
        """Проверка кода активации администратора"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute('''
                SELECT * FROM activation_codes 
                WHERE code = ? AND is_used = FALSE
            ''', (code.upper(),))
            return await cursor.fetchone()
    
    async def use_activation_code(self, code: str, user_id: int):
        """Использование кода активации"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                UPDATE activation_codes 
                SET is_used = TRUE, used_by = ?, used_at = ?
                WHERE code = ?
            ''', (user_id, datetime.now(), code.upper()))
            await db.commit()
    
    async def create_admin_code(self, code: str):
        """Создание одноразового кода активации администратора"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute('''
                    INSERT INTO activation_codes (code, role, created_at)
                    VALUES (?, 'admin', ?)
                ''', (code.upper(), datetime.now()))
                await db.commit()
                return True
            except aiosqlite.IntegrityError:
                return False
    
    async def user_exists(self, telegram_id: int):
        user = await self.get_user(telegram_id)
        return user is not None
    
    async def check_client_code_exists(self, client_code: str):
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute(
                'SELECT telegram_id FROM users WHERE client_code = ?', 
                (client_code,)
            )
            result = await cursor.fetchone()
            return result is not None
    
    async def add_request_stat(self, user_id: int, request_type: str, request_text: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO request_statistics (user_id, request_type, 
                                              request_text, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, request_type, request_text, datetime.now()))
            await db.commit()
    
    async def add_feedback(self, user_id: int, feedback_type: str, message: str):
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO feedback (user_id, feedback_type, message, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, feedback_type, message, datetime.now()))
            await db.commit()

    async def get_statistics(self):
        """Получение статистики для администратора"""
        async with aiosqlite.connect(self.db_path) as db:
            # Статистика пользователей
            cursor = await db.execute("SELECT user_type, COUNT(*) FROM users GROUP BY user_type")
            type_stats = await cursor.fetchall()

            stats = {'total_users': 0, 'clients': 0, 'employees': 0, 'admins': 0}
            for user_type, count in type_stats:
                stats['total_users'] += count
                if user_type == 'client':
                    stats['clients'] = count
                elif user_type == 'employee':
                    stats['employees'] = count

            # Считаем админов отдельно
            cursor = await db.execute("SELECT COUNT(*) FROM users WHERE role = 'admin'")
            admin_count = await cursor.fetchone()
            stats['admins'] = admin_count[0] if admin_count else 0

            # Статистика запросов
            cursor = await db.execute("SELECT request_type, COUNT(*) FROM request_statistics GROUP BY request_type")
            request_stats = await cursor.fetchall()

            stats['total_requests'] = 0
            stats['questions'] = 0
            stats['callbacks'] = 0
            for req_type, count in request_stats:
                stats['total_requests'] += count
                if req_type == 'question':
                    stats['questions'] = count
                elif req_type == 'callback_request':
                    stats['callbacks'] = count

            # Статистика обратной связи
            cursor = await db.execute("SELECT feedback_type, COUNT(*) FROM feedback GROUP BY feedback_type")
            feedback_stats = await cursor.fetchall()

            stats['suggestions'] = 0
            stats['complaints'] = 0
            for fb_type, count in feedback_stats:
                if fb_type == 'suggestion':
                    stats['suggestions'] = count
                elif fb_type == 'complaint':
                    stats['complaints'] = count

            return stats
        
    async def add_memory(self, user_id: int, type: str, content: str):
        """Сохранение памяти разговора"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                INSERT INTO conversation_memory (user_id, type, content)
                VALUES (?, ?, ?)
            ''', (user_id, type, content))
            await db.commit()

    async def get_buffer(self, user_id: int) -> list[str]:
        """Получение буфера сообщений"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute('''
                SELECT content FROM conversation_memory
                WHERE user_id = ? AND type = 'buffer'
                ORDER BY timestamp
            ''', (user_id,))
            rows = await cursor.fetchall()
            return [r[0] for r in rows]

    async def clear_buffer(self, user_id: int):
        """Очистка буфера сообщений"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                DELETE FROM conversation_memory
                WHERE user_id = ? AND type = 'buffer'
            ''', (user_id,))
            await db.commit()

    async def get_latest_summary(self, user_id: int) -> str | None:
        """Получение последней сводки разговора"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute('''
                SELECT content FROM conversation_memory
                WHERE user_id = ? AND type = 'summary'
                ORDER BY timestamp DESC
                LIMIT 1
            ''', (user_id,))
            row = await cursor.fetchone()
            return row[0] if row else None

---- src\database\__init__.py ----

---- tools\email_sender.py ----
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import logging
from config import EMAIL_HOST, EMAIL_PORT, EMAIL_LOGIN, EMAIL_PASSWORD, EMAIL_TO

logger = logging.getLogger(__name__)

async def send_callback_email(user_data: dict, phone: str, message: str):
    """Отправка email о заказе обратного звонка"""
    try:
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f'Заказ обратного звонка - {user_data.get("username", "Неизвестный пользователь")}'
        msg['From'] = EMAIL_LOGIN
        msg['To'] = EMAIL_TO
        
        html = f"""
        <html>
          <body style="font-family: Arial, sans-serif;">
            <h2>Новый заказ обратного звонка</h2>
            <p><strong>Дата и время:</strong> {datetime.now().strftime('%d.%m.%Y %H:%M')}</p>
            
            <h3>Информация о клиенте:</h3>
            <ul>
              <li><strong>Имя:</strong> {user_data.get('username', 'Не указано')}</li>
              <li><strong>Код клиента:</strong> {user_data.get('client_code', 'Не указан')}</li>
              <li><strong>Питомец:</strong> {user_data.get('pet_name', 'Не указан')} ({user_data.get('pet_type', 'Не указан')})</li>
              <li><strong>Telegram ID:</strong> {user_data.get('telegram_id', 'Не указан')}</li>
            </ul>
            
            <h3>Контактные данные:</h3>
            <ul>
              <li><strong>Телефон:</strong> {phone}</li>
            </ul>
            
            <h3>Сообщение:</h3>
            <p style="background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
              {message}
            </p>
            
            <hr>
            <p style="color: #666; font-size: 12px;">
              Это автоматическое сообщение от бота ветеринарной клиники
            </p>
          </body>
        </html>
        """
        
        # Текстовая версия
        text = f"""
        Новый заказ обратного звонка
        
        Дата и время: {datetime.now().strftime('%d.%m.%Y %H:%M')}
        
        Информация о клиенте:
        - Имя: {user_data.get('username', 'Не указано')}
        - Код клиента: {user_data.get('client_code', 'Не указан')}
        - Питомец: {user_data.get('pet_name', 'Не указан')} ({user_data.get('pet_type', 'Не указан')})
        - Telegram ID: {user_data.get('telegram_id', 'Не указан')}
        
        Контактные данные:
        - Телефон: {phone}
        
        Сообщение:
        {message}
        
        ---
        Это автоматическое сообщение от бота ветеринарной клиники
        """
        
        part1 = MIMEText(text, 'plain')
        part2 = MIMEText(html, 'html')
        
        msg.attach(part1)
        msg.attach(part2)
        
        # Отправляем email
        if EMAIL_LOGIN and EMAIL_PASSWORD:
            await aiosmtplib.send(
                msg,
                hostname=EMAIL_HOST,
                port=EMAIL_PORT,
                start_tls=True,
                username=EMAIL_LOGIN,
                password=EMAIL_PASSWORD,
            )
            logger.info(f"Email успешно отправлен на {EMAIL_TO}")
            return True
        else:
            logger.error("Email credentials not configured")
            return False
            
    except Exception as e:
        logger.error(f"Ошибка при отправке email: {e}")
        return False

---- utils\email_sender.py ----
# utils/email_sender.py
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import logging
from config import EMAIL_HOST, EMAIL_PORT, EMAIL_LOGIN, EMAIL_PASSWORD, EMAIL_TO

# Настроим более подробное логирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def send_feedback_email(user_data: dict, feedback_type: str, message: str):
    """Отправка email о предложениях и жалобах"""
    try:
        type_text = "Предложение" if feedback_type == "suggestion" else "Жалоба"
        
        # Определяем тип пользователя для отображения
        user_type_text = "Неизвестно"
        if user_data.get('user_type') == 'client':
            user_type_text = f"Клиент ({user_data.get('client_code', 'Не указан')})"
        elif user_data.get('user_type') == 'employee':
            dept = user_data.get('department_function', '')
            dept_map = {'laboratory': 'Лаборатория', 'sales': 'Продажи', 'support': 'Поддержка'}
            dept_text = dept_map.get(dept, dept)
            user_type_text = f"Сотрудник ({dept_text})"
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f'{type_text} - {user_data.get("name", "Неизвестный пользователь")}'
        msg['From'] = EMAIL_LOGIN
        msg['To'] = EMAIL_TO
        
        html = f"""
        <html>
          <body style="font-family: Arial, sans-serif;">
            <h2>{type_text}</h2>
            <p><strong>Дата и время:</strong> {datetime.now().strftime('%d.%m.%Y %H:%M')}</p>
            
            <h3>Информация о пользователе:</h3>
            <ul>
              <li><strong>Имя:</strong> {user_data.get('name', 'Не указано')}</li>
              <li><strong>Тип:</strong> {user_type_text}</li>
              <li><strong>Telegram ID:</strong> {user_data.get('telegram_id', 'Не указан')}</li>
            </ul>
            
            <h3>Текст обращения:</h3>
            <p style="background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
              {message}
            </p>
          </body>
        </html>
        """
        
        text = f"""
        {type_text}
        
        Дата и время: {datetime.now().strftime('%d.%m.%Y %H:%M')}
        
        Информация о пользователе:
        - Имя: {user_data.get('name', 'Не указано')}
        - Тип: {user_type_text}
        - Telegram ID: {user_data.get('telegram_id', 'Не указан')}
        
        Текст обращения:
        {message}
        """
        
        part1 = MIMEText(text, 'plain', 'utf-8')
        part2 = MIMEText(html, 'html', 'utf-8')
        
        msg.attach(part1)
        msg.attach(part2)
        
        if EMAIL_LOGIN and EMAIL_PASSWORD:
            logger.info(f"Attempting to send email from {EMAIL_LOGIN} to {EMAIL_TO}")
            logger.info(f"Using SMTP server: smtp.yandex.ru:465")
            
            response = await aiosmtplib.send(
                msg,
                hostname='smtp.yandex.ru',
                port=465,
                use_tls=True,
                username=EMAIL_LOGIN,
                password=EMAIL_PASSWORD,
            )
            
            logger.info(f"Email sent successfully. Response: {response}")
            return True
        else:
            logger.error("Email credentials not configured")
            return False
            
    except Exception as e:
        logger.error(f"Ошибка при отправке email: {e}", exc_info=True)
        return False

async def send_callback_email(user_data: dict, phone: str, message: str):
    """Отправка email о заказе обратного звонка"""
    try:
        # Определяем тип пользователя для отображения
        user_type_text = "Неизвестно"
        additional_info = ""
        
        if user_data.get('user_type') == 'client':
            user_type_text = "Ветеринарный врач клиники-партнера"
            additional_info = f"""
              <li><strong>Код клиента:</strong> {user_data.get('client_code', 'Не указан')}</li>
              <li><strong>Специализация:</strong> {user_data.get('specialization', 'Не указана')}</li>
            """
        elif user_data.get('user_type') == 'employee':
            dept = user_data.get('department_function', '')
            dept_map = {'laboratory': 'Лаборатория', 'sales': 'Продажи', 'support': 'Поддержка'}
            dept_text = dept_map.get(dept, dept)
            user_type_text = "Сотрудник VET UNION"
            additional_info = f"""
              <li><strong>Регион:</strong> {user_data.get('region', 'Не указан')}</li>
              <li><strong>Функция:</strong> {dept_text}</li>
            """
        
        # Создаем сообщение
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f'Заказ обратного звонка - {user_data.get("name", "Неизвестный пользователь")}'
        msg['From'] = EMAIL_LOGIN
        msg['To'] = EMAIL_TO
        # Добавим заголовки для лучшей доставляемости
        msg['Reply-To'] = EMAIL_LOGIN
        msg['X-Mailer'] = 'Python/aiosmtplib'
        
        # HTML версия письма
        html = f"""
        <html>
          <head>
            <meta charset="utf-8">
          </head>
          <body style="font-family: Arial, sans-serif;">
            <h2>Новый заказ обратного звонка</h2>
            <p><strong>Дата и время:</strong> {datetime.now().strftime('%d.%m.%Y %H:%M')}</p>
            
            <h3>Информация о пользователе:</h3>
            <ul>
              <li><strong>Имя:</strong> {user_data.get('name', 'Не указано')}</li>
              <li><strong>Тип:</strong> {user_type_text}</li>
              {additional_info}
              <li><strong>Telegram ID:</strong> {user_data.get('telegram_id', 'Не указан')}</li>
            </ul>
            
            <h3>Контактные данные:</h3>
            <ul>
              <li><strong>Телефон:</strong> {phone}</li>
            </ul>
            
            <h3>Сообщение:</h3>
            <p style="background-color: #f0f0f0; padding: 10px; border-radius: 5px;">
              {message}
            </p>
            
            <hr>
            <p style="color: #666; font-size: 12px;">
              Это автоматическое сообщение от бота лаборатории VET UNION
            </p>
          </body>
        </html>
        """
        
        # Текстовая версия
        text = f"""
        Новый заказ обратного звонка
        
        Дата и время: {datetime.now().strftime('%d.%m.%Y %H:%M')}
        
        Информация о пользователе:
        - Имя: {user_data.get('name', 'Не указано')}
        - Тип: {user_type_text}
        - Telegram ID: {user_data.get('telegram_id', 'Не указан')}
        
        Контактные данные:
        - Телефон: {phone}
        
        Сообщение:
        {message}
        
        ---
        Это автоматическое сообщение от бота лаборатории VET UNION
        """
        
        part1 = MIMEText(text, 'plain', 'utf-8')
        part2 = MIMEText(html, 'html', 'utf-8')
        
        msg.attach(part1)
        msg.attach(part2)
        
        # Отправляем email
        if EMAIL_LOGIN and EMAIL_PASSWORD:
            logger.info(f"Attempting to send callback email from {EMAIL_LOGIN} to {EMAIL_TO}")
            logger.info(f"Subject: {msg['Subject']}")
            logger.info(f"User data: {user_data}")
            
            response = await aiosmtplib.send(
                msg,
                hostname='smtp.yandex.ru',
                port=465,
                use_tls=True,
                username=EMAIL_LOGIN,
                password=EMAIL_PASSWORD,
            )
            
            logger.info(f"Email sent successfully. SMTP Response: {response}")
            return True
        else:
            logger.error("Email credentials not configured")
            return False
            
    except aiosmtplib.SMTPException as e:
        logger.error(f"SMTP error: {e}", exc_info=True)
        return False
    except Exception as e:
        logger.error(f"Ошибка при отправке email: {e}", exc_info=True)
        return False

---- utils\json_extractor.py ----
import json
import re
from typing import Any, Optional, Union

def extract_json(content: str) -> Union[dict[str, Any], str]:
    """
    Attempts to extract and parse a JSON object from a given string.

    The function handles the following cases:
    1. Direct JSON content wrapped in ```json ... ``` blocks.
    2. Automatically replaces Python-style 'None' with JSON-valid 'null'.
    3. Fallback to extracting the last JSON-looking substring.
    4. Partial JSON blocks within the content.

    Args:
        content (str): The raw input string potentially containing JSON.

    Returns:
        Union[dict[str, Any], str]: A parsed JSON object if successful, otherwise the original string.
    """
    def try_parse(json_str: str) -> Optional[dict[str, Any]]:
        try:
            return json.loads(json_str)
        except json.JSONDecodeError:
            return None

    content_cleaned = re.sub(r'^```(?:json)?\s*|\s*```$', '', content.strip(), flags=re.DOTALL) # Strip code block markers like ```json ... ```
    content_cleaned = re.sub(r'\bNone\b', 'null', content_cleaned) # Replace Python-style None or 'None' with JSON null
    content_cleaned = re.sub(r'"\s*None\s*"', 'null', content_cleaned)

    # Attempt 1: Parse full cleaned content
    result = try_parse(content_cleaned)
    if result is not None:
        return result

    # Attempt 2: Try substring from last '{' to last '}'
    last_open = content_cleaned.rfind('{')
    last_close = content_cleaned.rfind('}')
    if last_open != -1 and last_close > last_open:
        result = try_parse(content_cleaned[last_open:last_close + 1])
        if result is not None:
            return result

    # Attempt 3: Try all shallow JSON-like blocks
    json_blocks = re.findall(r'(?s)\{.*?\}', content_cleaned)
    if json_blocks:
        for block in reversed(json_blocks):
            result = try_parse(block)
            if result is not None:
                return result

    # Parsing failed in all strategies — return original content (or None, then def extract_json(content: str) -> Optional[dict[str, Any]])
    return None

---- utils\test_environment.py ----
import sys

REQUIRED_PYTHON = "python3"
REQUIRED_MAJOR = 3


def main():
    if sys.version_info.major != REQUIRED_MAJOR:
        raise TypeError(f"This project requires Python {REQUIRED_MAJOR}. Found: Python {sys.version}")
    else:
        print(">>> Development environment passes all tests!")


if __name__ == '__main__':
    main()

---- utils\__init__.py ----

PS C:\Users\Legion\AI_VET_Assistant-2> Get-ChildItem -Path notebooks -Filter "*.ipynb" -Name
data_review.ipynb
OpenRouterStats.ipynb

PS C:\Users\Legion\AI_VET_Assistant-2> Get-Content .env
OPENROUTER_API_KEY = 'секрет'
BOT_API_KEY = 'секрет'
DEEPINFRA_API_KEY = 'секрет'



# Yandex SMTP
EMAIL_PASSWORD=gpphhyzvggsuygpo
EMAIL_TO=hihion10@gmail.com
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=587
EMAIL_LOGIN=kirill.lvovich.asd@yandex.by

# --- core numeric / data stack ---
numpy
pandas
scipy
scikit-learn

# --- visualization ---
matplotlib
seaborn

# --- experiment helpers ---
tqdm          # progress bars
ipython
jupyter
ipykernel

# --- configuration / logging ---
python-dotenv
loguru

# --- Windows‑specific console colors ---
colorama


pyarrow==20.0.0
aiohttp==3.11.18
transformers==4.51.3
asyncio==3.4.3
aiogram
openpyxl==3.1.5
langchain-community==0.3.25
sentence-transformers==4.1.0
chromadb==1.0.12
langchain-huggingface==0.3.0
email-validator==2.2.0
aiosmtplib==3.0.1
aiosqlite==0.21.0
Pillow==10.0.0
chromadb==0.4.24